# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
# derSuessmann <arcade-book-de@dersuessmann.de>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Arcade Fall 2018\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-09 19:32+0200\n"
"PO-Revision-Date: 2019-07-15 09:42+0200\n"
"Last-Translator: derSuessmann <arcade-book-de@dersuessmann.de>\n"
"Language-Team: German <arcade-book-de@dersuessmann.de>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"X-Generator: Gtranslator 3.32.1\n"

#: ../../source/chapters/24_searching/searching.rst:2
msgid "Searching"
msgstr "Suchen"

#: ../../source/chapters/24_searching/searching.rst:4
msgid ""
"Searching is an important and very common operation that computers do all "
"the time. Searches are used every time someone does a ctrl-f for \"find\", "
"when a user uses \"type-to\" to quickly select an item, or when a web server "
"pulls information about a customer to present a customized web page with the "
"customer's order."
msgstr ""
"Das Suchen ist eine wichtige und sehr häufige Aufgabe, die Rechner ständig "
"ausführen. Suchanfragen werden jedes Mal verwendet, wenn jemand eine Strg-F-"
"Taste für \"Suchen\" drückt, wenn ein Benutzer ein Element mit "
"Autovervollständigung schnell auswählt oder wenn ein Webserver Informationen "
"über einen Kunden abruft, um eine angepasste Webseite mit dem Kundenauftrag "
"zu präsentieren."

msgid ".. image:: chapters/24_searching/search.png"
msgstr ".. image:: chapters/24_searching/search.png"

#: ../../source/chapters/24_searching/searching.rst:13
msgid ""
"There are a lot of ways to search for data. Google has based an entire multi-"
"billion dollar company on this fact. This chapter introduces the two "
"simplest methods for searching, the linear search and the binary search."
msgstr ""
"Es gibt viele Möglichkeiten, nach Daten zu suchen. Google hat eine ganze "
"Multi-Milliarden-Dollar-Firma auf diese Tatsache gegründet. In diesem "
"Kapitel werden die zwei einfachsten Suchmethoden vorgestellt, die lineare "
"Suche und die binäre Suche."

#: ../../source/chapters/24_searching/searching.rst:18
msgid "Reading From a File"
msgstr "Aus einer Datei lesen"

#: ../../source/chapters/24_searching/searching.rst:24
msgid ""
"Before discussing how to search we need to learn how to read data from a "
"file. Reading in a data set from a file is way more fun than typing it in by "
"hand each time."
msgstr ""
"Bevor wir uns mit der Suche befassen, müssen wir lernen, wie Daten aus einer "
"Datei gelesen werden. Das Einlesen eines Datensatzes aus einer Datei macht "
"wesentlich mehr Spaß, als ihn jedes Mal von Hand einzugeben."

#: ../../source/chapters/24_searching/searching.rst:28
msgid ""
"Let's say we need to create a program that will allow us to quickly find the "
"name of a super-villain. To start with, our program needs a database of "
"super-villains. To download this data set, download and save this file:"
msgstr ""
"Angenommen, wir müssen ein Programm erstellen, mit dem wir schnell den Namen "
"eines Superschurken finden können. Zu Beginn benötigt unser Programm eine "
"Datenbank mit Superschurken. Um diesen Datensatz herunterzuladen, lade diese "
"Datei herunter und speichere sie:"

#: ../../source/chapters/24_searching/searching.rst:32
msgid "`super_villains.txt`_"
msgstr "`super_villains.txt`_"

#: ../../source/chapters/24_searching/searching.rst:36
msgid ""
"These are random names generated by the `nine.frenchboys.net`_ website, "
"although last I checked they no longer have a super-villain generator. They "
"have other cool random name generators though."
msgstr ""
"Dies sind zufällige Namen, die von der `nine.frenchboys.net`_-Website "
"generiert wurden. (Obwohl den Superschurken-Generator beim letzten Mal, wo "
"ich nachgesehen habe, nicht mehr gab). Sie haben aber auch andere coole "
"Zufallsgeneratoren."

#: ../../source/chapters/24_searching/searching.rst:42
msgid "Save this file and remember which directory you saved it to."
msgstr ""
"Speichere diese Datei und merke dir, in welchem ​​Verzeichnis du sie "
"gespeichert hast."

#: ../../source/chapters/24_searching/searching.rst:44
msgid ""
"In the same directory as ``super_villains.txt``, create, save, and run the "
"following Python program:"
msgstr ""
"Erstelle im selben Verzeichnis wie \"super_villains.txt\" folgendes Python-"
"Programm, speichere es und führe es aus:"

#: ../../source/chapters/24_searching/searching.rst:47
#: ../../source/chapters/24_searching/searching.rst:99
msgid "Read in a file"
msgstr "Datei einlesen"

#: ../../source/chapters/24_searching/searching.rst:47
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        print(line)\n"
"\n"
"\n"
"main()"
msgstr ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        print(line)\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/24_searching/searching.rst:66
msgid ""
"There is only one new command in this code: ``open``. Because it is a built-"
"in function like ``print``, there is no need for an ``import``. Full details "
"on this function can be found in the `Python documentation`_ but at this "
"point the documentation for that command is so technical it might not even "
"be worth looking at."
msgstr ""
"In diesem Code gibt es nur eine neue Anweisung: ``open``. Da es sich um eine "
"integrierte Funktion wie ``print`` handelt, ist kein ``import`` "
"erforderlich. Ausführliche Informationen zu dieser Funktion findest du in "
"der `Python-Dokumentation`_, die Dokumentation für diese Anweisung ist "
"jedoch zu diesem Zeitpunkt so technisch, dass sie möglicherweise nicht "
"einmal einen Blick wert ist."

#: ../../source/chapters/24_searching/searching.rst:74
msgid ""
"The above program has two problems with it, but it provides a simple example "
"of reading in a file. Line 6 opens a file and gets it ready to be read. The "
"name of the file is in between the quotes. The new variable ``my_file`` is "
"an object that represents the file being read. Line 9 shows how a normal "
"``for`` loop may be used to read through a file line by line. Think of the "
"file as a list of lines, and the new variable line will be set to each of "
"those lines as the program runs through the loop."
msgstr ""
"Das obige Programm weist zwei Probleme auf, bietet jedoch ein einfaches "
"Beispiel für das Einlesen einer Datei. Zeile 6 öffnet eine Datei und macht "
"sie zum Lesen bereit. Der Name der Datei steht zwischen den "
"Anführungszeichen. Die neue Variable ``my_file`` ist ein Objekt, das die "
"gelesene Datei darstellt. Zeile 9 zeigt, wie eine normale ``for``-Schleife "
"verwendet werden kann, um eine Datei zeilenweise durchzulesen. Stelle dir "
"die Datei als eine Liste von Zeilen vor, und die neue Variable ``line`` wird "
"auf jede dieser Zeilen gesetzt, wenn das Programm die Schleife durchläuft."

#: ../../source/chapters/24_searching/searching.rst:82
msgid ""
"Try running the program. One of the problems with the it is that the text is "
"printed double-spaced. The reason for this is that each line pulled out of "
"the file and stored in the variable line includes the carriage return as "
"part of the string. Remember the carriage return and line feed introduced "
"back in Chapter 1? The ``print`` statement adds yet another carriage return "
"and the result is double-spaced output."
msgstr ""
"Führe das Programm aus. Eines der Probleme dabei ist, dass der Text mit "
"einer zusätzlichen Leerzeile ausgegeben wird. Der Grund dafür ist, dass jede "
"Zeile, die aus der Datei geholt und in der Variablen ``line`` gespeichert "
"wird, das Zeilenende als Teil der Zeichenfolge enthält. Erinnere dich an den "
"Wagenrücklauf und den Zeilenvorschub, die in Kapitel 1 eingeführt wurden? "
"Die ``print``-Anweisung fügt einen weiteres Zeilenende hinzu und das "
"Ergebnis ist eine Ausgabe mit einer zusätzlichen Leerzeile."

#: ../../source/chapters/24_searching/searching.rst:89
msgid ""
"The second problem is that the file is opened, but not closed. This problem "
"isn't as obvious as the double-spacing issue, but it is important. The "
"Windows operating system can only open so many files at once. A file can "
"normally only be opened by one program at a time. Leaving a file open will "
"limit what other programs can do with the file and take up system resources. "
"It is necessary to close the file to let Windows know the program is no "
"longer working with that file. In this case it is not too important because "
"once any program is done running, the Windows will automatically close any "
"files left open. But since it is a bad habit to program like that, let's "
"update the code:"
msgstr ""
"Das zweite Problem ist, dass die Datei geöffnet, aber nicht geschlossen "
"wird. Dieses Problem ist nicht so offensichtlich wie das Problem der "
"zusätzlichen Leerzeile, aber es ist wichtig. Das Windows-Betriebssystem kann "
"nur eine bestimmte Anzahl von Dateien gleichzeitig öffnen. Eine Datei kann "
"normalerweise nur von einem Programm gleichzeitig geöffnet werden. Wenn Sie "
"eine Datei geöffnet lassen, können andere Programme nur eingeschränkt mit "
"der Datei arbeiten und Systemressourcen belegen. Es ist notwendig, die Datei "
"zu schließen, um Windows mitzuteilen, dass das Programm nicht mehr mit "
"dieser Datei arbeitet. In diesem Fall ist dies nicht allzu wichtig, da "
"Windows nach dem Ausführen eines Programms alle noch geöffneten Dateien "
"automatisch schließt. Aber da es eine schlechte Angewohnheit ist, so zu "
"programmieren, aktualisieren wir den Code:"

#: ../../source/chapters/24_searching/searching.rst:99
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"        print(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"\n"
"main()"
msgstr ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"        print(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/24_searching/searching.rst:122
msgid ""
"The listing above works better. It has two new additions. On line 4 is a "
"call to the ``strip`` method built into every ``String`` class. This "
"function returns a new string without the trailing spaces and carriage "
"returns of the original string. The method does not alter the original "
"string but instead creates a new one. This line of code would not work:"
msgstr ""
"Das obige Programm funktioniert besser. Es hat zwei neue Ergänzungen. In "
"Zeile 4 steht ein Aufruf der Methode ``strip``, die in jede Klasse "
"``String`` eingebaut ist. Diese Funktion gibt eine neue Zeichenfolge ohne "
"die nachfolgenden Leerzeichen und Zeilenende-Zeichen der ursprünglichen "
"Zeichenfolge zurück. Die Methode ändert die ursprüngliche Zeichenfolge "
"nicht, sondern erstellt eine neue. Diese Codezeile würde nicht funktionieren:"

#: ../../source/chapters/24_searching/searching.rst:128
msgid "line.strip()"
msgstr "line.strip()"

#: ../../source/chapters/24_searching/searching.rst:132
msgid ""
"If the programmer wants the original variable to reference the new string, "
"she must assign it to the new returned string as shown on line 4."
msgstr ""
"Wenn der Programmierer möchte, dass die ursprüngliche Variable auf die neue "
"Zeichenfolge verweist, muss er sie der neuen zurückgegebenen Zeichenfolge "
"wie in Zeile 4 gezeigt zuweisen."

#: ../../source/chapters/24_searching/searching.rst:135
msgid ""
"The second addition is on line 7. This closes the file so that the operating "
"system doesn't have to go around later and clean up open files after the "
"program ends."
msgstr ""
"Der zweite Erweiterung befindet sich in Zeile 7. Dadurch wird die Datei "
"geschlossen, sodass das Betriebssystem nach dem Beenden des Programms nicht "
"mehr nachschauen und geöffnete Dateien aufräumen muss."

#: ../../source/chapters/24_searching/searching.rst:142
msgid "Reading Into an Array"
msgstr "Einlesen in ein Array"

#: ../../source/chapters/24_searching/searching.rst:144
msgid ""
"It is useful to read in the contents of a file to an array so that the "
"program can do processing on it later. This can easily be done in python "
"with the following code:"
msgstr ""
"Es ist nützlich, den Inhalt einer Datei in ein Array einzulesen, damit das "
"Programm sie später verarbeiten kann. Dies kann einfach in Python mit dem "
"folgenden Code durchgeführt werden:"

#: ../../source/chapters/24_searching/searching.rst:149
msgid "Read in a file from disk and put it in an array"
msgstr "Liest eine Datei von der Festplatte ein und legt sie in einem Array ab"

#: ../../source/chapters/24_searching/searching.rst:149
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print( \"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"\n"
"main()"
msgstr ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print( \"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/24_searching/searching.rst:179
msgid ""
"This combines the new pattern of how to read a file, along with the "
"previously learned pattern of how to create an empty array and append to it "
"as new data comes in, which was shown back in :ref:`append_to_list`. To "
"verify the file was read into the array correctly a programmer could print "
"the length of the array:"
msgstr ""
"Dies kombiniert das neue Muster zum Lesen einer Datei mit dem zuvor "
"erlernten Muster zum Erstellen eines leeren Arrays und zum Anhängen, wenn "
"neue Daten eingehen. Dies wurde unter :ref:`append_to_list` gezeigt. Um zu "
"überprüfen, ob die Datei korrekt in das Array eingelesen wurde, kann ein "
"Programmierer die Länge des Arrays ausgeben:"

#: ../../source/chapters/24_searching/searching.rst:184
msgid "print( \"There were\",len(name_list),\"names in the file.\")"
msgstr "print( \"There were\",len(name_list),\"names in the file.\")"

#: ../../source/chapters/24_searching/searching.rst:188
msgid "Or the programmer could print the entire contents of the array:"
msgstr "Oder der Programmierer kann den gesamten Inhalt des Arrays ausgeben:"

#: ../../source/chapters/24_searching/searching.rst:190
msgid ""
"for name in name_list:\n"
"    print(name)"
msgstr ""
"for name in name_list:\n"
"    print(name)"

#: ../../source/chapters/24_searching/searching.rst:195
msgid ""
"Go ahead and make sure you can read in the file before continuing on to the "
"different searches."
msgstr ""
"Stelle sicher, dass du die Datei lesen kannst, bevor du mit den "
"verschiedenen Suchvorgängen fortfahren."

#: ../../source/chapters/24_searching/searching.rst:199
msgid "Linear Search"
msgstr "Lineare Suche"

#: ../../source/chapters/24_searching/searching.rst:201
msgid ""
"If a program has a set of data in an array, how can it go about finding "
"where a specific element is? This can be done one of two ways. The first "
"method is to use a *linear search*. This starts at the first element, and "
"keeps comparing elements until it finds the desired element (or runs out of "
"elements.)"
msgstr ""
"Wenn ein Programm eine Menge von Daten in einem Array enthält, wie kann es "
"dann herausfinden, wo sich ein bestimmtes Element befindet? Dies kann auf "
"zwei Arten erfolgen. Die erste Methode ist die Verwendung einer *linearen "
"Suche*. Dies beginnt beim ersten Element und führt den Vergleich der "
"Elemente fort, bis das gewünschte Element gefunden wurde (oder keine "
"Elemente mehr vorhanden sind)."

#: ../../source/chapters/24_searching/searching.rst:209
msgid "Linear Search Algorithm"
msgstr "Linearer Suchalgorithmus"

#: ../../source/chapters/24_searching/searching.rst:215
#: ../../source/chapters/24_searching/searching.rst:262
#: ../../source/chapters/24_searching/searching.rst:271
msgid "Linear search"
msgstr "Lineare Suche"

#: ../../source/chapters/24_searching/searching.rst:215
msgid ""
"# --- Linear search\n"
"key = \"Morgiana the Shrew\"\n"
"\n"
"# Start at the beginning of the list\n"
"current_list_position = 0\n"
"\n"
"# Loop until you reach the end of the list, or the value at the\n"
"# current position is equal to the key\n"
"while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"\n"
"    # Advance to the next item in the list\n"
"    current_list_position += 1\n"
"\n"
"if current_list_position < len(name_list):\n"
"    print(\"The name is at position\", current_list_position)\n"
"else:\n"
"    print(\"The name was not in the list.\")"
msgstr ""
"# --- Linear search\n"
"key = \"Morgiana the Shrew\"\n"
"\n"
"# Start at the beginning of the list\n"
"current_list_position = 0\n"
"\n"
"# Loop until you reach the end of the list, or the value at the\n"
"# current position is equal to the key\n"
"while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"\n"
"    # Advance to the next item in the list\n"
"    current_list_position += 1\n"
"\n"
"if current_list_position < len(name_list):\n"
"    print(\"The name is at position\", current_list_position)\n"
"else:\n"
"    print(\"The name was not in the list.\")"

#: ../../source/chapters/24_searching/searching.rst:237
msgid ""
"The linear search is rather simple. Line 5 sets up an increment variable "
"that will keep track of exactly where in the list the program needs to check "
"next. The first element that needs to be checked is zero, so "
"``current_list_position`` is set to zero."
msgstr ""
"Die lineare Suche ist ziemlich einfach. Zeile 5 erstellt eine "
"Inkrementvariable, die genau festhält, wo in der Liste das Programm als "
"nächstes nachsehen muss. Das erste Element, das überprüft werden muss, steht "
"an der Position Null, also wird ``current_list_position`` auf Null gesetzt."

#: ../../source/chapters/24_searching/searching.rst:241
msgid ""
"The next line is a bit more complex. The computer needs to keep looping "
"until one of two things happens. It finds the element, or it runs out of "
"elements. The first comparison sees if the current element we are checking "
"is less than the length of the list. If so, we can keep looping. The second "
"comparison sees if the current element in the name list is equal to the name "
"we are searching for."
msgstr ""
"Die nächste Zeile ist etwas komplexer. Der Rechner muss so lange eine "
"Schleife ausführen, bis eine der beiden Situationen eintritt: Es findet das "
"Element oder es gehen ihm die Elemente aus. Beim ersten Vergleich wird "
"festgestellt, ob das aktuelle Position, die wir überprüfen, vor dem Ende der "
"Liste liegt. In diesem Fall können wir die Schleife fortsetzen. Beim zweiten "
"Vergleich wird festgestellt, ob das aktuelle Element in der Namensliste dem "
"gesuchten Namen entspricht."

#: ../../source/chapters/24_searching/searching.rst:248
msgid ""
"This check to see if the program has run out of elements *must occur first*. "
"Otherwise the program will check against a non-existent element which will "
"cause an error."
msgstr ""
"Diese Prüfung, um festzustellen, ob das Programm keine Elemente mehr hat, "
"muss zuerst erfolgen. Andernfalls prüft das Programm auf ein nicht "
"vorhandenes Element, was einen Fehler verursacht."

#: ../../source/chapters/24_searching/searching.rst:252
msgid ""
"Line 12 simply moves to the next element if the conditions to keep searching "
"are met in line 9."
msgstr ""
"Zeile 12 wechselt einfach zum nächsten Element, wenn die Bedingungen für die "
"weitere Suche in Zeile 9 erfüllt sind."

#: ../../source/chapters/24_searching/searching.rst:255
msgid ""
"At the end of the loop, the program checks to see if the end of the list was "
"reached on line 14. Remember, a list of n elements is numbered 0 to n-1. "
"Therefore if i is equal to the length of the list, the end has been reached. "
"If it is less, we found the element."
msgstr ""
"Am Ende der Schleife prüft das Programm, ob das Ende der Liste in Zeile 14 "
"erreicht wurde. Denke daran, dass eine Liste mit n Elementen von 0 bis n-1 "
"nummeriert ist. Wenn also i gleich der Länge der Liste ist, ist das Ende "
"erreicht. Wenn es weniger ist, haben wir das Element gefunden."

#: ../../source/chapters/24_searching/searching.rst:260
msgid ""
"The full example with both the reading in the file and the search is below:"
msgstr ""
"Das vollständige Beispiel mit dem Einlesen der Datei und der Suche findest "
"du unten:"

#: ../../source/chapters/24_searching/searching.rst:262
msgid ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print(\"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"    # --- Linear search\n"
"    key = \"Morgiana the Shrew\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    if current_list_position < len(name_list):\n"
"        print(\"The name is at position\", current_list_position)\n"
"    else:\n"
"        print(\"The name was not in the list.\")\n"
"\n"
"\n"
"main()\n"
msgstr ""
"def main():\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(\"super_villains.txt\")\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    print(\"There were\", len(name_list), \"names in the file.\")\n"
"\n"
"    # --- Linear search\n"
"    key = \"Morgiana the Shrew\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    if current_list_position < len(name_list):\n"
"        print(\"The name is at position\", current_list_position)\n"
"    else:\n"
"        print(\"The name was not in the list.\")\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/24_searching/searching.rst:268
msgid ""
"We can improve on this example by moving both the reading of the file and "
"the search into their own functions:"
msgstr ""
"Wir können dieses Beispiel verbessern, indem wir sowohl das Lesen der Datei "
"als auch die Suche in ihre eigenen Funktionen verschieben:"

#: ../../source/chapters/24_searching/searching.rst:271
msgid ""
"def read_in_file(file_name):\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(file_name)\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    return name_list\n"
"\n"
"\n"
"def linear_search(key, name_list):\n"
"    \"\"\" Linear search \"\"\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    return current_list_position\n"
"\n"
"\n"
"def main():\n"
"\n"
"    key = \"Morgiana the Shrew\"\n"
"    name_list = read_in_file(\"super_villains.txt\")\n"
"    list_position = linear_search(key, name_list)\n"
"\n"
"    if list_position < len(name_list):\n"
"        print(\"The name\", key, \"is at position\", list_position)\n"
"    else:\n"
"        print(\"The name\", key, \"was not in the list.\")\n"
"\n"
"\n"
"main()\n"
msgstr ""
"def read_in_file(file_name):\n"
"    \"\"\" Read in lines from a file \"\"\"\n"
"\n"
"    # Open the file for reading, and store a pointer to it in the new\n"
"    # variable \"file\"\n"
"    my_file = open(file_name)\n"
"\n"
"    # Create an empty list to store our names\n"
"    name_list = []\n"
"\n"
"    # Loop through each line in the file like a list\n"
"    for line in my_file:\n"
"        # Remove any line feed, carriage returns or spaces at the end of the "
"line\n"
"        line = line.strip()\n"
"\n"
"        # Add the name to the list\n"
"        name_list.append(line)\n"
"\n"
"    my_file.close()\n"
"\n"
"    return name_list\n"
"\n"
"\n"
"def linear_search(key, name_list):\n"
"    \"\"\" Linear search \"\"\"\n"
"\n"
"    # Start at the beginning of the list\n"
"    current_list_position = 0\n"
"\n"
"    # Loop until you reach the end of the list, or the value at the\n"
"    # current position is equal to the key\n"
"    while current_list_position < len(name_list) and "
"name_list[current_list_position] != key:\n"
"\n"
"        # Advance to the next item in the list\n"
"        current_list_position += 1\n"
"\n"
"    return current_list_position\n"
"\n"
"\n"
"def main():\n"
"\n"
"    key = \"Morgiana the Shrew\"\n"
"    name_list = read_in_file(\"super_villains.txt\")\n"
"    list_position = linear_search(key, name_list)\n"
"\n"
"    if list_position < len(name_list):\n"
"        print(\"The name\", key, \"is at position\", list_position)\n"
"    else:\n"
"        print(\"The name\", key, \"was not in the list.\")\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/24_searching/searching.rst:277
msgid "Variations On The Linear Search"
msgstr "Variationen der linearen Suche"

#: ../../source/chapters/24_searching/searching.rst:279
msgid ""
"Variations on the linear search can be used to create several common "
"algorithms. Specifically, you can use it to see if *any* items in a list "
"match a property, or if *all* items match a property. You can also use it to "
"pull all matching items out of a list."
msgstr ""
"Variationen der linearen Suche können verwendet werden, um mehrere "
"allgemeine Algorithmen zu erstellen. Insbesondere kann man damit "
"feststellen, ob *alle* Elemente in einer Liste mit einer Eigenschaft "
"übereinstimmen oder ob *alle* Elemente mit einer Eigenschaft übereinstimmen. "
"Man kann sie auch verwenden, um alle übereinstimmenden Elemente aus einer "
"Liste zu entfernen."

#: ../../source/chapters/24_searching/searching.rst:285
#: ../../source/chapters/24_searching/searching.rst:415
msgid "Does At Least One Item Have a Property?"
msgstr "Hat mindestens ein Gegenstand eine Eigenschaft?"

#: ../../source/chapters/24_searching/searching.rst:287
msgid ""
"For example, here is a function that uses the linear search to see if there "
"is an item in ``my_list`` that matches the value in ``key``."
msgstr ""
"Zum Beispiel ist hier eine Funktion, die die lineare Suche verwendet, um zu "
"sehen, ob es ein Element in ``my_list`` gibt, das mit dem Wert in ``key`` "
"übereinstimmt."

#: ../../source/chapters/24_searching/searching.rst:290
msgid "check_if_one_item_has_property_v1"
msgstr "check_if_one_item_has_property_v1"

#: ../../source/chapters/24_searching/searching.rst:290
msgid ""
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"
msgstr ""
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"

#: ../../source/chapters/24_searching/searching.rst:311
msgid ""
"Using the ``break`` statement, which exits a loop early, we can simplify the "
"code:"
msgstr ""
"Mit der ``break``-Anweisung, die eine Schleife vorzeitig beendet, können wir "
"den Code vereinfachen:"

#: ../../source/chapters/24_searching/searching.rst:314
msgid "check_if_one_item_has_property_v2"
msgstr "check_if_one_item_has_property_v2"

#: ../../source/chapters/24_searching/searching.rst:314
msgid ""
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False"
msgstr ""
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False"

#: ../../source/chapters/24_searching/searching.rst:332
#: ../../source/chapters/24_searching/searching.rst:461
msgid "Do All Items Have a Property?"
msgstr "Haben alle Gegenstände eine Eigenschaft?"

#: ../../source/chapters/24_searching/searching.rst:334
msgid ""
"How would you test to see if *all* items in a list match a property? We just "
"need to reverse a few things in the algorithm above."
msgstr ""
"Wie würden man testen, ob *alle* Elemente in einer Liste mit einer "
"Eigenschaft übereinstimmen? Wir müssen nur ein paar Dinge im obigen "
"Algorithmus umkehren."

#: ../../source/chapters/24_searching/searching.rst:337
msgid "check_if_all_items_have_property"
msgstr "check_if_all_items_have_property"

#: ../../source/chapters/24_searching/searching.rst:337
msgid ""
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True"
msgstr ""
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True"

#: ../../source/chapters/24_searching/searching.rst:356
#: ../../source/chapters/24_searching/searching.rst:480
msgid "Create a List With All Items Matching a Property"
msgstr ""
"Erstellen einer Liste mit allen Elementen, die einer Eigenschaft entsprechen"

#: ../../source/chapters/24_searching/searching.rst:358
msgid ""
"Another common operation is to grab all the items out of a list that match:"
msgstr ""
"Eine weitere häufige Operation besteht darin, alle übereinstimmenden "
"Elemente aus einer Liste zu entfernen:"

#: ../../source/chapters/24_searching/searching.rst:360
msgid "get_matching_items"
msgstr "get_matching_items"

#: ../../source/chapters/24_searching/searching.rst:360
msgid ""
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list"
msgstr ""
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list"

#: ../../source/chapters/24_searching/searching.rst:377
msgid "Full Example"
msgstr "Vollständiges Beispiel"

#: ../../source/chapters/24_searching/searching.rst:379
msgid "For a full example, see below:"
msgstr "Ein vollständiges Beispiel findest du unten:"

#: ../../source/chapters/24_searching/searching.rst:381
msgid "linear_search_variations_2.py"
msgstr "linear_search_variations_2.py"

#: ../../source/chapters/24_searching/searching.rst:381
msgid ""
"import random\n"
"\n"
"\n"
"def create_list(list_size):\n"
"    \"\"\" Create a list of random numbers \"\"\"\n"
"    my_list = []\n"
"\n"
"    for i in range(list_size):\n"
"        my_list.append(random.randrange(100))\n"
"\n"
"    return my_list\n"
"\n"
"\n"
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True\n"
"\n"
"\n"
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"\n"
"    # Create a list of 50 numbers\n"
"    my_list = create_list(50)\n"
"    print(my_list)\n"
"\n"
"    # Is at least one item zero?\n"
"    key = 0\n"
"    result = check_if_one_item_has_property_v1(my_list, 0)\n"
"    if result:\n"
"        print(\"At least one item in the list is\", key)\n"
"    else:\n"
"        print(\"No item in the list is\", key)\n"
"\n"
"    # Get items that match the key\n"
"    matching_list = get_matching_items(my_list, key)\n"
"    print(\"Matching items:\", matching_list)\n"
"\n"
"    # Are all items matching?\n"
"    result = check_if_all_items_have_property(my_list, key)\n"
"    print(\"All items in random list matching?\", result)\n"
"\n"
"    other_list = [0, 0, 0, 0, 0]\n"
"    result = check_if_all_items_have_property(other_list, key)\n"
"    print(\"All items in other list matching?\", result)\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import random\n"
"\n"
"\n"
"def create_list(list_size):\n"
"    \"\"\" Create a list of random numbers \"\"\"\n"
"    my_list = []\n"
"\n"
"    for i in range(list_size):\n"
"        my_list.append(random.randrange(100))\n"
"\n"
"    return my_list\n"
"\n"
"\n"
"def check_if_one_item_has_property_v1(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    list_position = 0\n"
"    while list_position < len(my_list) and my_list[list_position] != key:\n"
"        list_position += 1\n"
"\n"
"    if list_position < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_has_property_v2(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            # Found an item that matched. Return True\n"
"            return True\n"
"\n"
"    # Went through the whole list. Return False.\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_have_property(my_list, key):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item != key:\n"
"            # Found an item that didn't match. Return False.\n"
"            return False\n"
"\n"
"    # Got through the entire list. There were no mis-matches.\n"
"    return True\n"
"\n"
"\n"
"def get_matching_items(my_list, key):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item == key:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"\n"
"    # Create a list of 50 numbers\n"
"    my_list = create_list(50)\n"
"    print(my_list)\n"
"\n"
"    # Is at least one item zero?\n"
"    key = 0\n"
"    result = check_if_one_item_has_property_v1(my_list, 0)\n"
"    if result:\n"
"        print(\"At least one item in the list is\", key)\n"
"    else:\n"
"        print(\"No item in the list is\", key)\n"
"\n"
"    # Get items that match the key\n"
"    matching_list = get_matching_items(my_list, key)\n"
"    print(\"Matching items:\", matching_list)\n"
"\n"
"    # Are all items matching?\n"
"    result = check_if_all_items_have_property(my_list, key)\n"
"    print(\"All items in random list matching?\", result)\n"
"\n"
"    other_list = [0, 0, 0, 0, 0]\n"
"    result = check_if_all_items_have_property(other_list, key)\n"
"    print(\"All items in other list matching?\", result)\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/24_searching/searching.rst:388
msgid "Variations On The Linear Search With Objects"
msgstr "Variationen der linearen Suche mit Objekten"

#: ../../source/chapters/24_searching/searching.rst:390
msgid ""
"For example, say we had a list of objects for our text adventure. We might "
"want to check that list and see if any of the items are in the same room as "
"our player. Or if all the items are. Or we might want to build a list of "
"items that the user is carrying if they are all in a \"special\" room that "
"represents the player's inventory."
msgstr ""
"Nehmen wir zum Beispiel an, wir hätten eine Liste von Objekten für unser "
"Text-Adventure. Vielleicht möchten wir diese Liste überprüfen und "
"herausfinden, ob sich Gegenstände im selben Raum wie unsere Spielfigur "
"befinden. Oder ob alle Gegenstände im selben Raum sind. Oder wir möchten "
"eine Liste der Gegenstände erstellen, die die Spielfigur mit sich trägt, "
"wenn sich alle in einem \"speziellen\" Raum befinden, der das Inventar des "
"Spielers darstellt."

#: ../../source/chapters/24_searching/searching.rst:396
msgid "To begin with, we'd need to define our adventure object:"
msgstr "Zunächst müssen wir unsere Klasse für Objekte im Adventure definieren:"

#: ../../source/chapters/24_searching/searching.rst:398
msgid "Adventure Object class"
msgstr "Adventure-Objekt-Klasse"

#: ../../source/chapters/24_searching/searching.rst:398
msgid ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an object in a text adventure game \"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor.\"\"\"\n"
"\n"
"        # Description of the object\n"
"        self.description = description\n"
"\n"
"        # The number of the room that the object is in\n"
"        self.room = room"
msgstr ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an object in a text adventure game \"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor.\"\"\"\n"
"\n"
"        # Description of the object\n"
"        self.description = description\n"
"\n"
"        # The number of the room that the object is in\n"
"        self.room = room"

#: ../../source/chapters/24_searching/searching.rst:417
msgid "Is at least one object in the specified room? We can check."
msgstr ""
"Befindet sich mindestens ein Objekt im angegebenen Raum? Wir können das "
"überprüfen."

#: ../../source/chapters/24_searching/searching.rst:419
msgid "Check if list has an item that has a property - ``while`` loop"
msgstr ""
"Überprüfen, ob die Liste ein Element enthält, das eine Eigenschaft hat - "
"``while``-Schleife"

#: ../../source/chapters/24_searching/searching.rst:419
msgid ""
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"
msgstr ""
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False"

#: ../../source/chapters/24_searching/searching.rst:439
msgid ""
"This could also be done with a ``for`` loop. In this case, the loop will "
"exit early by using a ``return`` once the item has been found. The code is "
"shorter, but not every programmer would prefer it. Some programmers feel "
"that loops should not be prematurely ended with a ``return`` or ``break`` "
"statement. It all goes to personal preference, or the personal preference of "
"the person that is footing the bill."
msgstr ""
"Dies könnte auch mit einer ``for`` -Schleife geschehen. In diesem Fall wird "
"die Schleife mit einem ``return`` vorzeitig beendet, sobald der Gegenstand "
"gefunden wurde. Der Programmcode ist kürzer, aber nicht jeder Programmierer "
"würde ihn bevorzugen. Einige Programmierer sind der Meinung, dass Schleifen "
"nicht mit einer ``return``- oder ``break``-Anweisung vorzeitig beendet "
"werden sollten. Alles hängt von den persönlichen Vorlieben oder den "
"persönlichen Vorlieben der Person ab, die die Rechnung bezahlt."

#: ../../source/chapters/24_searching/searching.rst:446
msgid "Check if list has an item that has a property - ``for`` loop"
msgstr ""
"Überprüfen, ob die Liste ein Element enthält, das eine Eigenschaft hat - "
"``for``-Schleife"

#: ../../source/chapters/24_searching/searching.rst:446
msgid ""
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False"
msgstr ""
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False"

#: ../../source/chapters/24_searching/searching.rst:463
msgid ""
"Are all the adventure objects in the same room? This code is very similar to "
"the prior example. Spot the difference and see if you can figure out the "
"reason behind the change."
msgstr ""
"Befinden sich alle Adventure-Objekte im selben Raum? Dieser Code ist dem "
"vorherigen Beispiel sehr ähnlich. Erkennst du den Unterschied und siehst du "
"den Grund für die Änderung."

#: ../../source/chapters/24_searching/searching.rst:466
msgid "Check if all items have a property"
msgstr "Überprüfen, ob alle Elemente eine Eigenschaft haben"

#: ../../source/chapters/24_searching/searching.rst:466
msgid ""
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True"
msgstr ""
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True"

#: ../../source/chapters/24_searching/searching.rst:482
msgid ""
"What if you wanted a list of objects that are in room 5? This is a "
"combination of our prior code, and the code to append items to a list that "
"we learned about back in :ref:`intro-to-lists`."
msgstr ""
"Was ist, wenn du eine Liste der Objekte in Raum 5 haben möchtest? Dies ist "
"eine Kombination aus unserem vorherigen Code und dem Code zum Anhängen von "
"Elementen an eine Liste, die wir bereits kennengelernt haben (siehe :ref:"
"`Intro-to-Lists`)."

#: ../../source/chapters/24_searching/searching.rst:486
msgid "Create another list with all items matching a property"
msgstr ""
"Erstelle eine weitere Liste mit allen Elementen, die einer Eigenschaft "
"entsprechen"

#: ../../source/chapters/24_searching/searching.rst:486
msgid ""
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list"
msgstr ""
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list"

#: ../../source/chapters/24_searching/searching.rst:501
msgid ""
"How would you run all these in a test? The code above can be combined with "
"this code to run:"
msgstr ""
"Wie würdest du all dies testen? Der obige Code kann mit dem folgenden Code "
"kombiniert werden:"

#: ../../source/chapters/24_searching/searching.rst:504
msgid "Run Sample Functions"
msgstr "Beispielfunktionen ausführen"

#: ../../source/chapters/24_searching/searching.rst:504
msgid ""
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_has_property_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v1:\", result)\n"
"\n"
"    result = check_if_one_item_has_property_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v2:\", result)\n"
"\n"
"    result = check_if_all_items_have_property(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_have_property:\", result)\n"
"\n"
"    result = get_matching_items(object_list, 5)\n"
"    print(\"Number of items returned from test get_matching_items:\", "
"len(result))\n"
"\n"
"\n"
"main()"
msgstr ""
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_has_property_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v1:\", result)\n"
"\n"
"    result = check_if_one_item_has_property_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_has_property_v2:\", result)\n"
"\n"
"    result = check_if_all_items_have_property(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_have_property:\", result)\n"
"\n"
"    result = get_matching_items(object_list, 5)\n"
"    print(\"Number of items returned from test get_matching_items:\", "
"len(result))\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/24_searching/searching.rst:531
msgid "For a full working example:"
msgstr "Ein voll funktionsfähiges Beispiel:"

#: ../../source/chapters/24_searching/searching.rst:533
msgid "linear_search_variations.py"
msgstr "linear_search_variations.py"

#: ../../source/chapters/24_searching/searching.rst:533
msgid ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an alien\"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor. Set name and color\"\"\"\n"
"        self.description = description\n"
"        self.room = room\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True\n"
"\n"
"\n"
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_is_in_room_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v1:\", result)\n"
"\n"
"    result = check_if_one_item_is_in_room_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v2:\", result)\n"
"\n"
"    result = check_if_all_items_are_in_room(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_are_in_room:\", result)\n"
"\n"
"    result = get_items_in_room(object_list, 5)\n"
"    print(\"Number of items returned from test get_items_in_room:\", "
"len(result))\n"
"\n"
"\n"
"main()"
msgstr ""
"class AdventureObject:\n"
"    \"\"\" Class that defines an alien\"\"\"\n"
"\n"
"    def __init__(self, description, room):\n"
"        \"\"\" Constructor. Set name and color\"\"\"\n"
"        self.description = description\n"
"        self.room = room\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v1(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property.\n"
"    \"\"\"\n"
"    i = 0\n"
"    while i < len(my_list) and my_list[i].room != room:\n"
"        i += 1\n"
"\n"
"    if i < len(my_list):\n"
"        # Found an item with the property\n"
"        return True\n"
"    else:\n"
"        # There is no item with the property\n"
"        return False\n"
"\n"
"\n"
"def check_if_one_item_is_in_room_v2(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at least one item has a\n"
"    property. Works the same as v1, but less code.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            return True\n"
"    return False\n"
"\n"
"\n"
"def check_if_all_items_are_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Return true if at ALL items have a property.\n"
"    \"\"\"\n"
"    for item in my_list:\n"
"        if item.room != room:\n"
"            return False\n"
"    return True\n"
"\n"
"\n"
"def get_items_in_room(my_list, room):\n"
"    \"\"\"\n"
"    Build a brand new list that holds all the items\n"
"    that match our property.\n"
"    \"\"\"\n"
"    matching_list = []\n"
"    for item in my_list:\n"
"        if item.room == room:\n"
"            matching_list.append(item)\n"
"    return matching_list\n"
"\n"
"\n"
"def main():\n"
"    object_list = []\n"
"    object_list.append(AdventureObject(\"Key\", 5))\n"
"    object_list.append(AdventureObject(\"Bear\", 5))\n"
"    object_list.append(AdventureObject(\"Food\", 8))\n"
"    object_list.append(AdventureObject(\"Sword\", 2))\n"
"    object_list.append(AdventureObject(\"Wand\", 10))\n"
"\n"
"    result = check_if_one_item_is_in_room_v1(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v1:\", result)\n"
"\n"
"    result = check_if_one_item_is_in_room_v2(object_list, 5)\n"
"    print(\"Result of test check_if_one_item_is_in_room_v2:\", result)\n"
"\n"
"    result = check_if_all_items_are_in_room(object_list, 5)\n"
"    print(\"Result of test check_if_all_items_are_in_room:\", result)\n"
"\n"
"    result = get_items_in_room(object_list, 5)\n"
"    print(\"Number of items returned from test get_items_in_room:\", "
"len(result))\n"
"\n"
"\n"
"main()"

#: ../../source/chapters/24_searching/searching.rst:538
msgid ""
"These common algorithms can be used as part of a solution to a larger "
"problem, such as find all the addresses in a list of customers that aren't "
"valid."
msgstr ""
"Diese Standardalgorithmen können als Teil einer Lösung für ein größeres "
"Problem verwendet werden. Zum Beispiel, um alle Adressen in einer Liste von "
"Kunden zu finden, die ungültig sind."

#: ../../source/chapters/24_searching/searching.rst:544
msgid "Binary Search"
msgstr "Binäre Suche"

#: ../../source/chapters/24_searching/searching.rst:550
msgid ""
"A faster way to search a list is possible with the binary search. The "
"process of a binary search can be described by using the classic number "
"guessing game \"guess a number between 1 and 100\" as an example. To make it "
"easier to understand the process, let's modify the game to be \"guess a "
"number between 1 and 128.\" The number range is inclusive, meaning both 1 "
"and 128 are possibilities."
msgstr ""
"Mit der binären Suche kann man eine Liste schneller durchsuchen. Der Vorgang "
"einer binären Suche kann am Beispiel des klassischen Spiels \"Rate eine Zahl "
"zwischen 1 und 100\" beschrieben werden. Um das Verständnis des Vorgangs zu "
"erleichtern, ändern wir das Spiel so, dass \"eine Zahl zwischen 1 und 128 "
"erraten wird\". Der Nummernbereich ist inklusive, das heißt, sowohl 1 als "
"auch 128 sind möglich."

#: ../../source/chapters/24_searching/searching.rst:557
msgid ""
"If a person were to use the linear search as a method to guess the secret "
"number, the game would be rather long and boring."
msgstr ""
"Wenn jemand die lineare Suche als Methode zum Erraten der Geheimzahl "
"verwenden würde, wäre das Spiel ziemlich lang und langweilig."

#: ../../source/chapters/24_searching/searching.rst:560
msgid ""
"Guess a number 1 to 128: 1\n"
"Too low.\n"
"Guess a number 1 to 128: 2\n"
"Too low.\n"
"Guess a number 1 to 128: 3\n"
"Too low.\n"
"....\n"
"Guess a number 1 to 128: 93\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""
"Guess a number 1 to 128: 1\n"
"Too low.\n"
"Guess a number 1 to 128: 2\n"
"Too low.\n"
"Guess a number 1 to 128: 3\n"
"Too low.\n"
"....\n"
"Guess a number 1 to 128: 93\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"

#: ../../source/chapters/24_searching/searching.rst:574
msgid ""
"Most people will use a binary search to find the number. Here is an example "
"of playing the game using a binary search:"
msgstr ""
"Die meisten Leute verwenden die binäre Suche, um die Zahl zu finden. Hier "
"ist ein Beispiel für einen Spielverlauf mit einer binären Suche:"

#: ../../source/chapters/24_searching/searching.rst:576
msgid ""
"Guess a number 1 to 128: 64\n"
"Too low.\n"
"Guess a number 1 to 128: 96\n"
"Too high.\n"
"Guess a number 1 to 128: 80\n"
"Too low.\n"
"Guess a number 1 to 128: 88\n"
"Too low.\n"
"Guess a number 1 to 128: 92\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""
"Guess a number 1 to 128: 64\n"
"Too low.\n"
"Guess a number 1 to 128: 96\n"
"Too high.\n"
"Guess a number 1 to 128: 80\n"
"Too low.\n"
"Guess a number 1 to 128: 88\n"
"Too low.\n"
"Guess a number 1 to 128: 92\n"
"Too low.\n"
"Guess a number 1 to 128: 94\n"
"Correct!"

#: ../../source/chapters/24_searching/searching.rst:591
msgid ""
"Each time through the rounds of the number guessing game, the guesser is "
"able to eliminate one half of the problem space by getting a \"high\" or "
"\"low\" as a result of the guess."
msgstr ""
"Jedes Mal, wenn der Spieler eine Runde des Zahlenspiels durchläuft, ist er "
"in der Lage, die Hälfte des Problemraums zu eliminieren, indem er als "
"Ergebnis der Vermutung ein \"zu hoch\" oder \"zu niedrig\" erhält."

#: ../../source/chapters/24_searching/searching.rst:595
msgid ""
"In a binary search, it is necessary to track an upper and a lower bound of "
"the list that the answer can be in. The computer or number-guessing human "
"picks the midpoint of those elements. Revisiting the example:"
msgstr ""
"Bei einer binären Suche ist es erforderlich, eine obere und eine untere "
"Grenze der Liste zu verfolgen, in der sich die Antwort befinden kann. Der "
"Rechner oder der Mensch, der eine Zahl errät, wählt den Mittelpunkt dieser "
"Elemente aus. Das überarbeitete Beispiel:"

#: ../../source/chapters/24_searching/searching.rst:599
msgid ""
"A lower bound of 1, upper bound of 128, mid point of :math:`\\frac{128+1}{2}"
"=64.5`."
msgstr ""
"Eine Untergrenze von 1, Obergrenze von 128, Mittelpunkt von :math:`"
"\\frac{128+1}{2} = 64,5`."

#: ../../source/chapters/24_searching/searching.rst:602
msgid ""
"Guess a number 1 to 128: 64\n"
"Too low."
msgstr ""
"Guess a number 1 to 128: 64\n"
"Too low."

#: ../../source/chapters/24_searching/searching.rst:607
msgid ""
"A lower bound of 65, upper bound of 128, mid point of :math:`\\frac{65+128}"
"{2}=96.5`."
msgstr ""
"Eine Untergrenze von 65, Obergrenze von 128, Mittelpunkt von :math:`"
"\\frac{65+128}{2} = 96,5`."

#: ../../source/chapters/24_searching/searching.rst:610
msgid ""
"Guess a number 1 to 128: 96\n"
"Too high."
msgstr ""
"Guess a number 1 to 128: 96\n"
"Too high."

#: ../../source/chapters/24_searching/searching.rst:615
msgid ""
"A lower bound of 65, upper bound of 95, mid point of :math:`\\frac{65+95}{2}"
"=80`."
msgstr ""
"Eine Untergrenze von 65, Obergrenze von 95, Mittelpunkt von :math:`"
"\\frac{65+95}{2} = 80`."

#: ../../source/chapters/24_searching/searching.rst:618
msgid ""
"Guess a number 1 to 128: 80\n"
"Too low."
msgstr ""
"Guess a number 1 to 128: 80\n"
"Too low."

#: ../../source/chapters/24_searching/searching.rst:623
msgid ""
"A lower bound of 81, upper bound of 95, mid point of :math:`\\frac{81+95}{2}"
"=88`."
msgstr ""
"Eine Untergrenze von 81, Obergrenze von 95, Mittelpunkt von :math:`"
"\\frac{81+95}{2} = 88`."

#: ../../source/chapters/24_searching/searching.rst:626
msgid ""
"Guess a number 1 to 128: 88\n"
"Too low."
msgstr ""
"Guess a number 1 to 128: 88\n"
"Too low."

#: ../../source/chapters/24_searching/searching.rst:631
msgid ""
"A lower bound of 89, upper bound of 95, mid point of :math:`\\frac{89+95}{2}"
"=92`."
msgstr ""
"Eine Untergrenze von 89, Obergrenze von 95, Mittelpunkt von :math:`"
"\\frac{89+95}{2} = 92`."

#: ../../source/chapters/24_searching/searching.rst:634
msgid ""
"Guess a number 1 to 128: 92\n"
"Too low."
msgstr ""
"Guess a number 1 to 128: 92\n"
"Too low."

#: ../../source/chapters/24_searching/searching.rst:639
msgid ""
"A lower bound of 93, upper bound of 95, mid point of :math:`\\frac{93+95}{2}"
"=94`."
msgstr ""
"Eine Untergrenze von 93, Obergrenze von 95, Mittelpunkt von :math:`"
"\\frac{93+95}{2} = 94`."

#: ../../source/chapters/24_searching/searching.rst:642
msgid ""
"Guess a number 1 to 128: 94\n"
"Correct!"
msgstr ""
"Guess a number 1 to 128: 94\n"
"Correct!"

#: ../../source/chapters/24_searching/searching.rst:647
msgid ""
"A binary search requires significantly fewer guesses. Worst case, it can "
"guess a number between 1 and 128 in 7 guesses. One more guess raises the "
"limit to 256. 9 guesses can get a number between 1 and 512. With just 32 "
"guesses, a person can get a number between 1 and 4.2 billion."
msgstr ""
"Eine binäre Suche erfordert deutlich weniger Versuche. Im schlimmsten Fall "
"kann es eine Zahl zwischen 1 und 128 in sieben Schritten erraten. Eine "
"weitere Runde erhöht das Limit auf 256 Zahlen. 9 Runden können eine Zahl "
"zwischen 1 und 512 erhalten. Mit nur 32 Runden kann eine Person eine Zahl "
"zwischen 1 und 4,2 Milliarden erraten."

#: ../../source/chapters/24_searching/searching.rst:652
msgid ""
"To figure out how large the list can be given a certain number of guesses, "
"the formula works out like :math:`n=x^{g}` where :math:`n` is the size of "
"the list and :math:`g` is the number of guesses. For example:"
msgstr ""
"Um herauszufinden, wie groß die Liste mit einer bestimmten Anzahl von "
"Rateversuche sein kann, lautet die Formel wie folgt :math:`n = x^{g}` wobei :"
"math:`n` die Größe der Liste ist und :math:`g` ist die Anzahl der "
"Rateversuche. Zum Beispiel:"

#: ../../source/chapters/24_searching/searching.rst:656
msgid ":math:`2^7=128` (7 guesses can handle 128 different numbers)"
msgstr ""
":math:`2^7 = 128` (7 Rateversuch können 128 verschiedene Zahlen abarbeiten)"

#: ../../source/chapters/24_searching/searching.rst:657
msgid ":math:`2^8=256`"
msgstr ":math:`2^8 = 256`"

#: ../../source/chapters/24_searching/searching.rst:658
msgid ":math:`2^9=512`"
msgstr ":math:`2^9 = 512`"

#: ../../source/chapters/24_searching/searching.rst:659
msgid ":math:`2^{32}=4,294,967,296`"
msgstr ":math:`2^{32} = 4 294 967 296`"

#: ../../source/chapters/24_searching/searching.rst:662
msgid ""
"If you have the problem size, we can figure out the number of guesses using "
"the log function. Specifically, *log base 2*. If you don't specify a base, "
"most people will assume you mean the natural log with a base of :math:`e "
"\\approx 2.71828` which is not what we want. For example, using log base 2 "
"to find how many guesses:"
msgstr ""
"Wenn wir die Problemgröße haben, können wir die Anzahl der Vermutungen "
"mithilfe der Logarithmusfunktion ermitteln. Insbesondere *Lograithmus zur "
"Basis 2*. Wenn man keine Basis angibt, gehen die meisten Leute davon aus, "
"dass man den natürliche Logarithmus mit folgender Basis meint :math:`e "
"\\approx 2,71828`, was nicht das ist, was wir wollen. Verwenden wir "
"beispielsweise die Basis 2, um zu ermitteln, wie viele Rateversuche maximal "
"notwendig sind:"

#: ../../source/chapters/24_searching/searching.rst:668
msgid ":math:`log_2 128 = 7`"
msgstr ":math:`\\log_2(128) = 7`"

#: ../../source/chapters/24_searching/searching.rst:669
msgid ":math:`log_2 65,536 = 16`"
msgstr ":math:`\\log_2(65536) = 16`"

#: ../../source/chapters/24_searching/searching.rst:672
msgid ""
"Enough math! Where is the code? The code to do a binary search is more "
"complex than a linear search:"
msgstr ""
"Genug Mathe! Wo ist der Code? Der Code für eine binäre Suche ist komplexer "
"als eine lineare Suche:"

#: ../../source/chapters/24_searching/searching.rst:675
msgid "Binary search"
msgstr "Binäre Suche"

#: ../../source/chapters/24_searching/searching.rst:675
msgid ""
"# --- Binary search\n"
"key = \"Morgiana the Shrew\"\n"
"lower_bound = 0\n"
"upper_bound = len(name_list)-1\n"
"found = False\n"
"\n"
"# Loop until we find the item, or our upper/lower bounds meet\n"
"while lower_bound <= upper_bound and not found:\n"
"\n"
"    # Find the middle position\n"
"    middle_pos = (lower_bound + upper_bound) // 2\n"
"\n"
"    # Figure out if we:\n"
"    # move up the lower bound, or\n"
"    # move down the upper bound, or\n"
"    # we found what we are looking for\n"
"    if name_list[middle_pos] < key:\n"
"        lower_bound = middle_pos + 1\n"
"    elif name_list[middle_pos] > key:\n"
"        upper_bound = middle_pos - 1\n"
"    else:\n"
"        found = True\n"
"\n"
"if found:\n"
"    print( \"The name is at position\", middle_pos)\n"
"else:\n"
"    print( \"The name was not in the list.\" )"
msgstr ""
"# --- Binary search\n"
"key = \"Morgiana the Shrew\"\n"
"lower_bound = 0\n"
"upper_bound = len(name_list)-1\n"
"found = False\n"
"\n"
"# Loop until we find the item, or our upper/lower bounds meet\n"
"while lower_bound <= upper_bound and not found:\n"
"\n"
"    # Find the middle position\n"
"    middle_pos = (lower_bound + upper_bound) // 2\n"
"\n"
"    # Figure out if we:\n"
"    # move up the lower bound, or\n"
"    # move down the upper bound, or\n"
"    # we found what we are looking for\n"
"    if name_list[middle_pos] < key:\n"
"        lower_bound = middle_pos + 1\n"
"    elif name_list[middle_pos] > key:\n"
"        upper_bound = middle_pos - 1\n"
"    else:\n"
"        found = True\n"
"\n"
"if found:\n"
"    print( \"The name is at position\", middle_pos)\n"
"else:\n"
"    print( \"The name was not in the list.\" )"

#: ../../source/chapters/24_searching/searching.rst:707
msgid ""
"Since lists start at element zero, line 3 sets the lower bound to zero. Line "
"4 sets the upper bound to the length of the list minus one. So for a list of "
"100 elements the lower bound will be 0 and the upper bound 99."
msgstr ""
"Da Listen bei Element Null beginnen, setzt Zeile 3 die Untergrenze auf Null. "
"Zeile 4 setzt die Obergrenze auf die Länge der Liste minus eins. Für eine "
"Liste mit 100 Elementen ist die Untergrenze 0 und die Obergrenze 99."

#: ../../source/chapters/24_searching/searching.rst:711
msgid ""
"The Boolean variable on line 5 will be used to let the while loop know that "
"the element has been found."
msgstr ""
"Die boolesche Variable in Zeile 5 wird verwendet, um der ``while``-Schleife "
"mitzuteilen, dass das Element gefunden wurde."

#: ../../source/chapters/24_searching/searching.rst:714
msgid ""
"Line 8 checks to see if the element has been found or if we've run out of "
"elements. If we've run out of elements the lower bound will end up equaling "
"the upper bound."
msgstr ""
"Zeile 8 prüft, ob das Element gefunden wurde oder ob keine Elemente mehr "
"vorhanden sind. Wenn wir keine Elemente mehr haben, entspricht die "
"Untergrenze der Obergrenze."

#: ../../source/chapters/24_searching/searching.rst:718
msgid ""
"Line 11 finds the middle position. It is possible to get a middle position "
"of something like 64.5. It isn't possible to look up position 64.5. "
"(Although J.K. Rowling was rather clever in enough coming up with Platform :"
"math:`9\\frac{3}{4}`, that doesn't work here.) The best way of handling this "
"is to use the ``//`` operator first introduced way back in Chapter 1. This "
"is similar to the ``/`` operator, but will only return integer results. For "
"example, ``11 // 2`` would give 5 as an answer, rather than 5.5."
msgstr ""
"Zeile 11 findet die mittlere Position. Es ist möglich, eine mittlere "
"Position von etwa 64,5 zu erhalten. Es ist nicht möglich, Position 64,5 "
"nachzuschlagen. (Obwohl JK Rowling so clever war, die Platform :math:`9 "
"\\frac{3}{4}` zu finden, funktioniert das hier nicht.) Der beste Weg, dies "
"zu handhaben, ist, den ``//``-Operator zu verwenden. Der Operator wurde zum "
"ersten Mal in Kapitel 1 eingeführt. Er ähnelt dem Operator ``/``, gibt "
"jedoch nur ganzzahlige Ergebnisse zurück. Zum Beispiel würde ``11 // 2`` 5 "
"anstelle von 5,5 als Antwort geben."

#: ../../source/chapters/24_searching/searching.rst:726
msgid ""
"Starting at line 17, the program checks to see if the guess is high, low, or "
"correct. If the guess is low, the lower bound is moved up to just past the "
"guess. If the guess is too high, the upper bound is moved just below the "
"guess. If the answer has been found, ``found`` is set to ``True`` ending the "
"search."
msgstr ""
"Ab Zeile 17 prüft das Programm, ob die Vermutung zu hoch, zu niedrig oder "
"richtig ist. Wenn die Vermutung zu niedrig ist, wird die untere Grenze nach "
"oben verschoben, bis sie knapp hinter der Vermutung liegt. Wenn die "
"Schätzung zu hoch ist, wird die Obergrenze direkt unter die Schätzung "
"verschoben. Wenn die Antwort gefunden wurde, wird ``found`` auf ``True`` "
"gesetzt, um die Suche zu beenden."

#: ../../source/chapters/24_searching/searching.rst:732
msgid ""
"With the a list of 100 elements, a person can reasonably guess that on "
"average with the linear search, a program will have to check 50 of them "
"before finding the element. With the binary search, on average you'll still "
"need to do about seven guesses. In an advanced algorithms course you can "
"find the exact formula. For this course, just assume average and worst cases "
"are the same."
msgstr ""
"Bei einer Liste von 100 Elementen kann man vernünftigerweise annehmen, dass "
"ein Programm bei der linearen Suche im Durchschnitt 50 Elemente prüfen muss, "
"bevor es das Element findet. Bei der binären Suche müssen Sie im "
"Durchschnitt noch ungefähr sieben Vermutungen anstellen. In einem Kurs für "
"fortgeschrittene Algorithmen findest du die genaue Formel. Nimm für diesen "
"Kurs einfach an, dass Durchschnitt und schlechtester Fall gleich sind."
