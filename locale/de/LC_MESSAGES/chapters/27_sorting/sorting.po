# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
# derSuessmann <arcade-book-de@dersuessmann.de>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Arcade Fall 2018\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-09 19:32+0200\n"
"PO-Revision-Date: 2019-07-16 09:25+0200\n"
"Last-Translator: derSuessmann <arcade-book-de@dersuessmann.de>\n"
"Language-Team: German <arcade-book-de@dersuessmann.de>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"X-Generator: Gtranslator 3.32.1\n"

#: ../../source/chapters/27_sorting/sorting.rst:2
msgid "Sorting"
msgstr "Sortieren"

#: ../../source/chapters/27_sorting/sorting.rst:4
msgid ""
"Binary searches only work on lists that are in order. So how do programs get "
"a list in order? How does a program sort a list of items when the user "
"clicks a column heading, or otherwise needs something sorted?"
msgstr ""
"Die binäre Suche funktioniert nur bei Listen, die in der richtigen "
"Reihenfolge sind. Wie können Programme eine Liste in der richtigen "
"Reihenfolge erstellen? Wie sortiert ein Programm eine Liste von Elementen, "
"wenn der Benutzer auf eine Spaltenüberschrift klickt oder auf andere Weise "
"etwas Sortiertes benötigt?"

#: ../../source/chapters/27_sorting/sorting.rst:8
msgid ""
"There are several algorithms that do this. The two easiest algorithms for "
"sorting are the *selection sort* and the *insertion sort*. Other sorting "
"algorithms exist as well, such as the shell, merge, heap, and quick sorts."
msgstr ""
"Dafür gibt es mehrere Algorithmen. Die zwei einfachsten Algorithmen zum "
"Sortieren sind *Selectionsort* und *Insertionsort*. Es gibt auch andere "
"Sortieralgorithmen wie Shellsort, Mergesort, Heapsort und Quicksort."

#: ../../source/chapters/27_sorting/sorting.rst:12
msgid ""
"The best way to get an idea on how these sorts work is to watch them. To see "
"common sorting algorithms in action visit this excellent website:"
msgstr ""
"Der beste Weg, um eine Vorstellung davon zu bekommen, wie diese "
"Sortieralgorithmen funktionieren, ist, sie zu beobachten. Um die gängigen "
"Sortieralgorithmen in Aktion zu sehen, besuche diese hervorragende Website:"

#: ../../source/chapters/27_sorting/sorting.rst:15
msgid "http://www.sorting-algorithms.com"
msgstr "http://www.sorting-algorithms.com"

#: ../../source/chapters/27_sorting/sorting.rst:17
msgid ""
"Each sort has advantages and disadvantages. Some sort a list quickly if the "
"list is almost in order to begin with. Some sort a list quickly if the list "
"is in a completely random order. Other lists sort fast, but take more "
"memory. Understanding how sorts work is important in selecting the proper "
"sort for your program."
msgstr ""
"Jeder Sortieralgorithmus hat Vor- und Nachteile. Einige sortieren eine Liste "
"schnell, wenn die Liste fast in richtigen Reihenfolge ist. Einige sortieren "
"eine Liste schnell, wenn die Liste in einer völlig zufälligen Reihenfolge "
"vorliegt. Andere Listen werden schnell sortiert, benötigen jedoch mehr "
"Speicher. Es ist wichtig zu verstehen, wie Sortieralgorithmen funktionieren, "
"um den richtigen Algorithmus für ein Programm auszuwählen."

#: ../../source/chapters/27_sorting/sorting.rst:24
msgid "Swapping Values"
msgstr "Werte vertauschen"

#: ../../source/chapters/27_sorting/sorting.rst:30
msgid ""
"Before learning to sort, we need to learn how to swap values between two "
"variables. This is a common operation in many sorting algorithms. Suppose a "
"program has a list that looks like the following:"
msgstr ""
"Bevor wir sortieren lernen, müssen wir lernen, wie Werte von zwei Variablen "
"gegeneinander ausgetauscht werden. Dies ist eine übliche Operation in vielen "
"Sortieralgorithmen. Angenommen, ein Programm hat eine Liste, die wie folgt "
"aussieht:"

#: ../../source/chapters/27_sorting/sorting.rst:34
msgid "my_list = [15, 57, 14, 33, 72, 79, 26, 56, 42, 40]"
msgstr "my_list = [15, 57, 14, 33, 72, 79, 26, 56, 42, 40]"

#: ../../source/chapters/27_sorting/sorting.rst:38
msgid ""
"The developer wants to swap positions 0 and 2, which contain the numbers 15 "
"and 14 respectively. See Figure 18.1."
msgstr ""
"Der Entwickler möchte die Elemente an den Positionen 0 und 2 tauschen, die "
"die Zahlen 15 beziehungsweise 14 enthalten. Siehe Abbildung 18.1."

#: ../../source/chapters/27_sorting/sorting.rst:43
msgid ".. image:: chapters/27_sorting/sortgraph1.svg"
msgstr ".. image:: chapters/27_sorting/sortgraph1.svg"

#: ../../source/chapters/27_sorting/sorting.rst:43
msgid "Figure 27.1: Swapping values in an array"
msgstr "Abbildung 18.1: Werte in einem Array austauschen"

#: ../../source/chapters/27_sorting/sorting.rst:45
msgid "A first attempt at writing this code might look something like this:"
msgstr ""
"Ein erster Versuch, diesen Code zu schreiben, könnte ungefähr so ​​aussehen:"

#: ../../source/chapters/27_sorting/sorting.rst:47
msgid ""
"my_list[0] = my_list[2]\n"
"my_list[2] = my_list[0]"
msgstr ""
"my_list[0] = my_list[2]\n"
"my_list[2] = my_list[0]"

#: ../../source/chapters/27_sorting/sorting.rst:54
msgid ".. image:: chapters/27_sorting/sortgraph2.svg"
msgstr ".. image:: chapters/27_sorting/sortgraph2.svg"

#: ../../source/chapters/27_sorting/sorting.rst:54
msgid "Figure 27.2: Incorrect attempt to swap array values"
msgstr "Abbildung 18.2: Falscher Versuch, Array-Werte auszutauschen"

#: ../../source/chapters/27_sorting/sorting.rst:56
msgid ""
"See Figure 27.2 to get an idea on what would happen. This clearly does not "
"work. The first assignment ``list[0] = list[2]`` causes the value 15 that "
"exists in position 0 to be overwritten with the 14 in position 2 and "
"irretrievably lost. The next line with ``list[2] = list[0]`` just copies the "
"14 back to cell 2 which already has a 14."
msgstr ""
"In Abbildung 18.2 erhalten wir eine Vorstellung davon, was passieren würde. "
"Dies funktioniert eindeutig nicht. Die erste Zuweisung ``list[0] = list[2]`` "
"bewirkt, dass der in Position 0 vorhandene Wert 15 mit dem Wert 14 in "
"Position 2 überschrieben wird und unwiederbringlich verloren geht. Die "
"nächste Zeile mit ``list[2] = list[0]`` kopiert die 14 einfach zurück in "
"Zelle 2, die bereits eine 14 enthält."

#: ../../source/chapters/27_sorting/sorting.rst:62
msgid ""
"To fix this problem, swapping values in an array should be done in three "
"steps. It is necessary to create a temporary variable to hold a value during "
"the swap operation. See Figure 18.3. The code to do the swap looks like the "
"following:"
msgstr ""
"Um dieses Problem zu beheben, sollte man die Werte in einem Array in drei "
"Schritten austauschen. Es ist erforderlich, eine temporäre Variable zu "
"erstellen, um einen Wert während der Austauschoperation zu speichern. Siehe "
"Abbildung 18.3. Der Code für den Austausch sieht folgendermaßen aus:"

#: ../../source/chapters/27_sorting/sorting.rst:67
msgid "Swapping two values in an array"
msgstr "Zwei Werte in einem Array vertauschen"

#: ../../source/chapters/27_sorting/sorting.rst:67
msgid ""
"temp = my_list[0]\n"
"my_list[0] = my_list[2]\n"
"my_list[2] = temp"
msgstr ""
"temp = my_list[0]\n"
"my_list[0] = my_list[2]\n"
"my_list[2] = temp"

#: ../../source/chapters/27_sorting/sorting.rst:74
msgid ""
"The first line copies the value of position 0 into the ``temp`` variable. "
"This allows the code to write over position 0 with the value in position 2 "
"without data being lost. The final line takes the old value of position 0, "
"currently held in the ``temp`` variable, and places it in position 2."
msgstr ""
"Die erste Zeile kopiert den Wert von Position 0 in die Variable ``temp``. "
"Dadurch kann der Code die Position 0 mit dem Wert in Position 2 "
"überschreiben, ohne dass Daten verloren gehen. Die letzte Zeile nimmt den "
"alten Wert von Position 0, der derzeit in der Variablen ``temp`` enthalten "
"ist, und platziert ihn an Position 2."

#: ../../source/chapters/27_sorting/sorting.rst:81
msgid ".. image:: chapters/27_sorting/sortgraph1b.svg"
msgstr ".. image:: chapters/27_sorting/sortgraph1b.svg"

#: ../../source/chapters/27_sorting/sorting.rst:81
msgid "Figure 27.3: Correct method to swap array values"
msgstr "Abbildung 18.3: Richtige Methode zum Austauschen von Array-Werten"

#: ../../source/chapters/27_sorting/sorting.rst:84
#: ../../source/chapters/27_sorting/sorting.rst:105
msgid "Selection Sort"
msgstr "Selectionsort"

#: ../../source/chapters/27_sorting/sorting.rst:90
msgid ""
"The selection by looking at element 0. Then code next scans the rest of the "
"list from element 1 to n-1 to find the smallest number. The smallest number "
"is swapped into element 0. The code then moves on to element 1, then 2, and "
"so forth. Graphically, the sort looks like Figure 18.4."
msgstr ""
"Der Algorithmus beginnt mit dem Betrachten des Elements 0. Anschließend "
"durchsucht der Code noch den Rest der Liste von Element 1 bis n-1, um die "
"kleinste Zahl zu finden in der Liste zu finden. Die kleinste Zahl wird mit "
"dem Element 0 getauscht. Jetzt steht die kleinste Zahl an der Position 0. "
"Der Rest der Liste ist noch unsortiert. Der Algorithmus sucht dann das "
"kleinste Element in der Restliste und beginnt die Suche mit dem Element 1, "
"dann zu 2 und so weiter. Graphisch sieht die Sortierung wie in Abbildung "
"18.4 aus."

#: ../../source/chapters/27_sorting/sorting.rst:97
msgid ".. image:: chapters/27_sorting/sortgraph.svg"
msgstr ".. image:: chapters/27_sorting/sortgraph.svg"

#: ../../source/chapters/27_sorting/sorting.rst:97
msgid "Figure 27.4: Selection Sort"
msgstr "Abbildung 18.4: Selectionsort"

#: ../../source/chapters/27_sorting/sorting.rst:99
msgid ""
"The code for a selection sort involves two nested loops. The outside loop "
"tracks the current position that the code wants to swap the smallest value "
"into. The inside loop starts at the current location and scans to the right "
"in search of the smallest value. When it finds the smallest value, the swap "
"takes place."
msgstr ""
"Der Code für Selectionsort besteht aus zwei verschachtelten Schleifen. Die "
"äußere Schleife verfolgt die aktuelle Position, in die der kleinste Wert "
"kommen soll. Die innere Schleife beginnt an der aktuellen Position und sucht "
"nach dem kleinsten Wert nach rechts. Wenn die innere Schleife den kleinsten "
"Wert gefunden hat, vertauscht der Algorithmus den Wert an der aktuellen "
"Position mit dem Wert an der Position mit dem kleinsten Wert."

#: ../../source/chapters/27_sorting/sorting.rst:105
msgid ""
"def selection_sort(my_list):\n"
"    \"\"\" Sort a list using the selection sort \"\"\"\n"
"\n"
"    # Loop through the entire array\n"
"    for cur_pos in range(len(my_list)):\n"
"        # Find the position that has the smallest number\n"
"        # Start with the current position\n"
"        min_pos = cur_pos\n"
"\n"
"        # Scan left to right (end of the list)\n"
"        for scan_pos in range(cur_pos + 1, len(my_list)):\n"
"\n"
"            # Is this position smallest?\n"
"            if my_list[scan_pos] < my_list[min_pos]:\n"
"\n"
"                # It is, mark this position as the smallest\n"
"                min_pos = scan_pos\n"
"\n"
"        # Swap the two values\n"
"        temp = my_list[min_pos]\n"
"        my_list[min_pos] = my_list[cur_pos]\n"
"        my_list[cur_pos] = temp"
msgstr ""
"def selection_sort(my_list):\n"
"    \"\"\" Sort a list using the selection sort \"\"\"\n"
"\n"
"    # Loop through the entire array\n"
"    for cur_pos in range(len(my_list)):\n"
"        # Find the position that has the smallest number\n"
"        # Start with the current position\n"
"        min_pos = cur_pos\n"
"\n"
"        # Scan left to right (end of the list)\n"
"        for scan_pos in range(cur_pos + 1, len(my_list)):\n"
"\n"
"            # Is this position smallest?\n"
"            if my_list[scan_pos] < my_list[min_pos]:\n"
"\n"
"                # It is, mark this position as the smallest\n"
"                min_pos = scan_pos\n"
"\n"
"        # Swap the two values\n"
"        temp = my_list[min_pos]\n"
"        my_list[min_pos] = my_list[cur_pos]\n"
"        my_list[cur_pos] = temp"

#: ../../source/chapters/27_sorting/sorting.rst:132
msgid ""
"The outside loop will always run :math:`n` times. The inside loop will run "
"an average of :math:`\\frac{n}{2}` times per run of the outside loop. "
"Therefore the inside loop will run a total of :math:`n \\cdot \\frac{n}{2}` "
"or :math:`\\frac{n^2}{2}` times."
msgstr ""
"Die äußere Schleife läuft immer :math:`n` mal. Die innere Schleife wird "
"durchschnittlich :math:`\\frac{n}{2}` mal pro Lauf der äußeren Schleife "
"ausgeführt. Daher wird die innere Schleife insgesamt :math:`n\\cdot\\frac{n}"
"{2}` oder :math:`\\frac{n^2}{2}` mal ausgeführt. "

#: ../../source/chapters/27_sorting/sorting.rst:137
msgid ""
"This will be the case regardless if the list is in order or not. The loops' "
"efficiency may be improved by checking if ``min_pos`` and ``cur_pos`` are "
"equal before line 20. If those variables are equal, there is no need to do "
"the three lines of swap code."
msgstr ""
"Dies ist unabhängig davon der Fall, ob die Liste schon der Größe nach "
"sortiert ist oder nicht. Die Effizienz der Schleifen kann verbessert werden, "
"indem geprüft wird, ob ``min_pos`` und ``cur_pos`` vor Zeile 20 gleich sind. "
"Wenn diese Variablen gleich sind, müssen die drei Zeilen des Austausch-Codes "
"nicht ausgeführt werden."

#: ../../source/chapters/27_sorting/sorting.rst:142
msgid ""
"In order to test the selection sort code above, the following code may be "
"used. The first function will print out the list. The next code will create "
"a list of random numbers, print it, sort it, and then print it again. On "
"line 5 the print statement right-aligns the numbers to make the column of "
"numbers easier to read. Formatting ``print`` statements will be covered in a "
"later chapter."
msgstr ""
"Um den obigen Code des Selectionsort zu testen, kann das folgende Programm "
"verwendet werden. Die erste Funktion gibt die Liste aus. Der nächste "
"Programmcode erstellt eine Liste von Zufallszahlen, gibt sie aus, sortiert "
"sie und gibt sie dann erneut aus. In Zeile 5 richtet die ``print``-Anweisung "
"die Zahlen mit der rechtsbündig aus, damit die Zahlenspalte besser lesbar "
"ist. Die Formatierung von ``print``-Ausgaben wird in einem späteren Kapitel "
"behandelt."

#: ../../source/chapters/27_sorting/sorting.rst:149
msgid "Code to create and print list to sort"
msgstr "Code zum Erstellen und Ausgeben der zu sortierenden Liste"

#: ../../source/chapters/27_sorting/sorting.rst:149
msgid ""
"# Before this code, paste the selection sort and import random\n"
"\n"
"def print_list(my_list):\n"
"    for item in my_list:\n"
"        print(\"{:3}\".format(item), end=\"\")\n"
"    print()\n"
"\n"
"# Create a list of random numbers\n"
"my_list = []\n"
"for i in range(10):\n"
"    my_list.append(random.randrange(100))\n"
"\n"
"# Try out the sort\n"
"print_list(my_list)\n"
"selection_sort(my_list)\n"
"print_list(my_list)"
msgstr ""
"# Before this code, paste the selection sort and import random\n"
"\n"
"def print_list(my_list):\n"
"    for item in my_list:\n"
"        print(\"{:3}\".format(item), end=\"\")\n"
"    print()\n"
"\n"
"# Create a list of random numbers\n"
"my_list = []\n"
"for i in range(10):\n"
"    my_list.append(random.randrange(100))\n"
"\n"
"# Try out the sort\n"
"print_list(my_list)\n"
"selection_sort(my_list)\n"
"print_list(my_list)"

#: ../../source/chapters/27_sorting/sorting.rst:170
msgid "See an animation of the selection sort at:"
msgstr "Eine Animation des Selectionsort findest du unter:"

#: ../../source/chapters/27_sorting/sorting.rst:172
msgid "http://www.sorting-algorithms.com/selection-sort"
msgstr "http://www.sorting-algorithms.com/selection-sort"

#: ../../source/chapters/27_sorting/sorting.rst:174
msgid ""
"For a truly unique visualization of the selection sort, search YouTube for "
"\"selection sort dance\" or use this link:"
msgstr ""
"Durchsuche YouTube nach \"selection sort dance\" oder verwende diesen Link, "
"um eine wirklich einzigartige Visualisierung von Selectionsort zu erhalten:"

#: ../../source/chapters/27_sorting/sorting.rst:177
msgid "http://youtu.be/Ns4TPTC8whw"
msgstr "http://youtu.be/Ns4TPTC8whw"

#: ../../source/chapters/27_sorting/sorting.rst:179
msgid ""
"You also can trace through the code using `Selection Sort on Python Tutor`_."
msgstr ""
"Du kannst den Code auch mit `Selection Sort on Python Tutor`_ nachverfolgen."

#: ../../source/chapters/27_sorting/sorting.rst:184
#: ../../source/chapters/27_sorting/sorting.rst:229
msgid "Insertion Sort"
msgstr "Insertionsort"

#: ../../source/chapters/27_sorting/sorting.rst:190
msgid ""
"The insertion sort is similar to the selection sort in how the outer loop "
"works. The insertion sort starts at the left side of the array and works to "
"the right side. The difference is that the insertion sort does not select "
"the smallest element and put it into place; the insertion sort selects the "
"next element to the right of what was already sorted. Then it slides up each "
"larger element until it gets to the correct location to insert. Graphically, "
"it looks like Figure 18.5."
msgstr ""
"Insertionsort ähnelt Selectionsort in der Funktionsweise der äußeren "
"Schleife. Insertionsort beginnt auf der linken Seite des Arrays und arbeitet "
"sich nach rechts vor. Der Unterschied besteht darin, dass Insertionsort "
"nicht das kleinste Element auswählt und an die richtige Stelle setzt. "
"Insertionsort wählt das nächste Element rechts von dem aus, was in der Liste "
"bereits sortiert wurde und vergleicht diesen Wert mit jeden Wert links davon "
"in dem bereits sortierten Listenteil. Der Algorithmus schiebt jedes größere "
"Element in dem bereits sortierten Listenteil nach rechts, bis es an die "
"richtige Stelle zum Einfügen gelangt. Graphisch sieht es aus wie in "
"Abbildung 18.5."

#: ../../source/chapters/27_sorting/sorting.rst:200
msgid ".. image:: chapters/27_sorting/sortgraph4.svg"
msgstr ".. image:: chapters/27_sorting/sortgraph4.svg"

#: ../../source/chapters/27_sorting/sorting.rst:200
msgid "Figure 27.5: Insertion Sort"
msgstr "Abbildung 18.5: Insertionsort"

#: ../../source/chapters/27_sorting/sorting.rst:202
msgid ""
"The insertion sort breaks the list into two sections, the \"sorted\" half "
"and the \"unsorted\" half. In each round of the outside loop, the algorithm "
"will grab the next unsorted element and insert it into the list."
msgstr ""
"Insertionsort unterteilt die Liste in zwei Abschnitte, den sortierten Teil "
"und den unsortierten Teil. In jeder Runde der äußeren Schleife greift der "
"Algorithmus das nächste unsortierte Element und fügt es in die den "
"sortierten Teil der Liste ein."

#: ../../source/chapters/27_sorting/sorting.rst:206
msgid ""
"In the code below, the ``key_pos`` marks the boundary between the sorted and "
"unsorted portions of the list. The algorithm scans to the left of "
"``key_pos`` using the variable ``scan_pos``. Note that in the insertion "
"sort, ``scan_pos`` goes down to the left, rather than up to the right. Each "
"cell location that is larger than ``key_value`` gets moved up (to the right) "
"one location."
msgstr ""
"Im folgenden Code markiert ``key_pos`` die Grenze zwischen den sortierten "
"und unsortierten Teilen der Liste. Der Algorithmus scannt links von "
"``key_pos`` mit der Variablen ``scan_pos``. Beachte, dass ``scan_pos`` beim "
"Insertionsort nach links und nicht nach rechts läuft. Jede Zellenposition, "
"die größer als ``key_value`` ist, wird um eine Position nach oben (nach "
"rechts) verschoben."

# "puts to the right of it"
#: ../../source/chapters/27_sorting/sorting.rst:212
msgid ""
"When the loop finds a location smaller than ``key_value``, it stops and puts "
"``key_value`` to the left of it."
msgstr ""
"Wenn die Schleife eine Position findet, die kleiner als ``key_value`` ist, "
"stoppt sie und setzt ``key_value`` rechts davon ein."

#: ../../source/chapters/27_sorting/sorting.rst:215
msgid ""
"The outside loop with an insertion sort will run :math:`n` times. For each "
"run of the outside loop, the inside loop will run an average of :math:`"
"\\frac{n}{4}` times if the loop is randomly shuffled. In total, the inside "
"loop would run :math:`n\\cdot\\frac{n}{4}` times, or simplified,  :math:`"
"\\frac{n^2}{4}` times."
msgstr ""
"Die äußere Schleife vom Insertionsort wird :math:`n` mal ausgeführt. Für "
"jeden Durchgang der äußeren Schleife wird die innere Schleife "
"durchschnittlich :math:`\\frac{n}{4}` mal ausgeführt, wenn die Liste "
"zufällig gemischt ist. Insgesamt würde die innere Schleife :math:`n\\cdot"
"\\frac{n}{4}` mal oder vereinfacht :math:`\\frac{n^2}{4}` mal laufen."

#: ../../source/chapters/27_sorting/sorting.rst:220
msgid ""
"What's really important: If the loop is close to a sorted loop already, then "
"the inside loop does not run very much, and the sort time is closer to *n*. "
"The insertion sort is the fastest sort for nearly-sorted lists. If the list "
"is reversed, then the insertion sort is terrible."
msgstr ""
"Was wirklich wichtig ist: Befindet sich die Liste bereits in der Nähe einer "
"sortierten Liste, wird die innere Schleife nicht sehr häufig ausgeführt, und "
"die Sortierzeit liegt näher bei *n*. Insertionsort ist der schnellste "
"Algorithmus für nahezu sortierte Listen. Wenn die Liste umgekehrt sortiert "
"ist, ist Insertionsort fürchterlich."

#: ../../source/chapters/27_sorting/sorting.rst:226
msgid ""
"The selection sort doesn't really care what order the list is in to begin "
"with. It performs the same regardless."
msgstr ""
"Selectionsort ist es eigentlich egal, in welcher Reihenfolge sich die Liste "
"am Anfang befindet. Er verhält sich trotzdem gleich."

#: ../../source/chapters/27_sorting/sorting.rst:229
msgid ""
"def insertion_sort(my_list):\n"
"    \"\"\" Sort a list using the insertion sort \"\"\"\n"
"\n"
"    # Start at the second element (pos 1).\n"
"    # Use this element to insert into the\n"
"    # list.\n"
"    for key_pos in range(1, len(my_list)):\n"
"\n"
"        # Get the value of the element to insert\n"
"        key_value = my_list[key_pos]\n"
"\n"
"        # Scan from right to the left (start of list)\n"
"        scan_pos = key_pos - 1\n"
"\n"
"        # Loop each element, moving them up until\n"
"        # we reach the position the\n"
"        while (scan_pos >= 0) and (my_list[scan_pos] > key_value):\n"
"            my_list[scan_pos + 1] = my_list[scan_pos]\n"
"            scan_pos = scan_pos - 1\n"
"\n"
"        # Everything's been moved out of the way, insert\n"
"        # the key into the correct location\n"
"        my_list[scan_pos + 1] = key_value"
msgstr ""
"def insertion_sort(my_list):\n"
"    \"\"\" Sort a list using the insertion sort \"\"\"\n"
"\n"
"    # Start at the second element (pos 1).\n"
"    # Use this element to insert into the\n"
"    # list.\n"
"    for key_pos in range(1, len(my_list)):\n"
"\n"
"        # Get the value of the element to insert\n"
"        key_value = my_list[key_pos]\n"
"\n"
"        # Scan from right to the left (start of list)\n"
"        scan_pos = key_pos - 1\n"
"\n"
"        # Loop each element, moving them up until\n"
"        # we reach the position the\n"
"        while (scan_pos >= 0) and (my_list[scan_pos] > key_value):\n"
"            my_list[scan_pos + 1] = my_list[scan_pos]\n"
"            scan_pos = scan_pos - 1\n"
"\n"
"        # Everything's been moved out of the way, insert\n"
"        # the key into the correct location\n"
"        my_list[scan_pos + 1] = key_value"

#: ../../source/chapters/27_sorting/sorting.rst:257
msgid "See an animation of the insertion sort at:"
msgstr "Eine Animation der Insertionsort findet man unter:"

#: ../../source/chapters/27_sorting/sorting.rst:259
msgid "http://www.sorting-algorithms.com/insertion-sort"
msgstr "http://www.sorting-algorithms.com/insertion-sort"

#: ../../source/chapters/27_sorting/sorting.rst:261
msgid ""
"For another dance interpretation, search YouTube for \"insertion sort dance"
"\" or use this link:"
msgstr ""
"Durchsuche YouTube nach \"insertion sort dance\" oder verwende diesen Link, "
"um eine andere Tanzinterpretation zu erhalten:"

#: ../../source/chapters/27_sorting/sorting.rst:264
msgid "http://youtu.be/ROalU379l3U"
msgstr "http://youtu.be/ROalU379l3U"

#: ../../source/chapters/27_sorting/sorting.rst:266
msgid "You can trace through the code using `Insertion Sort on Python Tutor`_."
msgstr ""
"Du kannst den Code mit `Insertion Sort on Python Tutor`_ nachverfolgen."

#: ../../source/chapters/27_sorting/sorting.rst:273
#: ../../source/chapters/27_sorting/sorting.rst:275
msgid "Full Sorting Example"
msgstr "Vollständiges Sortierbeispiel"

#: ../../source/chapters/27_sorting/sorting.rst:275
msgid ""
"import random\n"
"\n"
"\n"
"def selection_sort(my_list):\n"
"    \"\"\" Sort a list using the selection sort \"\"\"\n"
"\n"
"    # Loop through the entire array\n"
"    for cur_pos in range(len(my_list)):\n"
"        # Find the position that has the smallest number\n"
"        # Start with the current position\n"
"        min_pos = cur_pos\n"
"\n"
"        # Scan left to right (end of the list)\n"
"        for scan_pos in range(cur_pos + 1, len(my_list)):\n"
"\n"
"            # Is this position smallest?\n"
"            if my_list[scan_pos] < my_list[min_pos]:\n"
"                # It is, mark this position as the smallest\n"
"                min_pos = scan_pos\n"
"\n"
"        # Swap the two values\n"
"        temp = my_list[min_pos]\n"
"        my_list[min_pos] = my_list[cur_pos]\n"
"        my_list[cur_pos] = temp\n"
"\n"
"\n"
"def insertion_sort(my_list):\n"
"    \"\"\" Sort a list using the insertion sort \"\"\"\n"
"\n"
"    # Start at the second element (pos 1).\n"
"    # Use this element to insert into the\n"
"    # list.\n"
"    for key_pos in range(1, len(my_list)):\n"
"\n"
"        # Get the value of the element to insert\n"
"        key_value = my_list[key_pos]\n"
"\n"
"        # Scan from right to the left (start of list)\n"
"        scan_pos = key_pos - 1\n"
"\n"
"        # Loop each element, moving them up until\n"
"        # we reach the position the\n"
"        while (scan_pos >= 0) and (my_list[scan_pos] > key_value):\n"
"            my_list[scan_pos + 1] = my_list[scan_pos]\n"
"            scan_pos = scan_pos - 1\n"
"\n"
"        # Everything's been moved out of the way, insert\n"
"        # the key into the correct location\n"
"        my_list[scan_pos + 1] = key_value\n"
"\n"
"\n"
"# This will point out a list\n"
"# For more information on the print formatting {:3}\n"
"# see the chapter on print formatting.\n"
"def print_list(my_list):\n"
"    for item in my_list:\n"
"        print(f\"{item:3}\", end=\"\")\n"
"    print()\n"
"\n"
"\n"
"def main():\n"
"    # Create two lists of the same random numbers\n"
"    list_for_selection_sort = []\n"
"    list_for_insertion_sort = []\n"
"    list_size = 10\n"
"    for i in range(list_size):\n"
"        new_number = random.randrange(100)\n"
"        list_for_selection_sort.append(new_number)\n"
"        list_for_insertion_sort.append(new_number)\n"
"\n"
"    # Print the original list\n"
"    print(\"Original List\")\n"
"    print_list(list_for_selection_sort)\n"
"\n"
"    # Use the selection sort and print the result\n"
"    print(\"Selection Sort\")\n"
"    selection_sort(list_for_selection_sort)\n"
"    print_list(list_for_selection_sort)\n"
"\n"
"    # Use the insertion sort and print the result\n"
"    print(\"Insertion Sort\")\n"
"    insertion_sort(list_for_insertion_sort)\n"
"    print_list(list_for_insertion_sort)\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import random\n"
"\n"
"\n"
"def selection_sort(my_list):\n"
"    \"\"\" Sort a list using the selection sort \"\"\"\n"
"\n"
"    # Loop through the entire array\n"
"    for cur_pos in range(len(my_list)):\n"
"        # Find the position that has the smallest number\n"
"        # Start with the current position\n"
"        min_pos = cur_pos\n"
"\n"
"        # Scan left to right (end of the list)\n"
"        for scan_pos in range(cur_pos + 1, len(my_list)):\n"
"\n"
"            # Is this position smallest?\n"
"            if my_list[scan_pos] < my_list[min_pos]:\n"
"                # It is, mark this position as the smallest\n"
"                min_pos = scan_pos\n"
"\n"
"        # Swap the two values\n"
"        temp = my_list[min_pos]\n"
"        my_list[min_pos] = my_list[cur_pos]\n"
"        my_list[cur_pos] = temp\n"
"\n"
"\n"
"def insertion_sort(my_list):\n"
"    \"\"\" Sort a list using the insertion sort \"\"\"\n"
"\n"
"    # Start at the second element (pos 1).\n"
"    # Use this element to insert into the\n"
"    # list.\n"
"    for key_pos in range(1, len(my_list)):\n"
"\n"
"        # Get the value of the element to insert\n"
"        key_value = my_list[key_pos]\n"
"\n"
"        # Scan from right to the left (start of list)\n"
"        scan_pos = key_pos - 1\n"
"\n"
"        # Loop each element, moving them up until\n"
"        # we reach the position the\n"
"        while (scan_pos >= 0) and (my_list[scan_pos] > key_value):\n"
"            my_list[scan_pos + 1] = my_list[scan_pos]\n"
"            scan_pos = scan_pos - 1\n"
"\n"
"        # Everything's been moved out of the way, insert\n"
"        # the key into the correct location\n"
"        my_list[scan_pos + 1] = key_value\n"
"\n"
"\n"
"# This will point out a list\n"
"# For more information on the print formatting {:3}\n"
"# see the chapter on print formatting.\n"
"def print_list(my_list):\n"
"    for item in my_list:\n"
"        print(f\"{item:3}\", end=\"\")\n"
"    print()\n"
"\n"
"\n"
"def main():\n"
"    # Create two lists of the same random numbers\n"
"    list_for_selection_sort = []\n"
"    list_for_insertion_sort = []\n"
"    list_size = 10\n"
"    for i in range(list_size):\n"
"        new_number = random.randrange(100)\n"
"        list_for_selection_sort.append(new_number)\n"
"        list_for_insertion_sort.append(new_number)\n"
"\n"
"    # Print the original list\n"
"    print(\"Original List\")\n"
"    print_list(list_for_selection_sort)\n"
"\n"
"    # Use the selection sort and print the result\n"
"    print(\"Selection Sort\")\n"
"    selection_sort(list_for_selection_sort)\n"
"    print_list(list_for_selection_sort)\n"
"\n"
"    # Use the insertion sort and print the result\n"
"    print(\"Insertion Sort\")\n"
"    insertion_sort(list_for_insertion_sort)\n"
"    print_list(list_for_insertion_sort)\n"
"\n"
"\n"
"main()\n"
