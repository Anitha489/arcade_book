# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Paul Vincent Craven
# This file is distributed under the same license as the Arcade package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
# derSuessmann <arcade-book-de@dersuessmann.de>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Arcade Fall 2018\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-03 12:51-0500\n"
"PO-Revision-Date: 2019-07-15 07:50+0200\n"
"Last-Translator: derSuessmann <arcade-book-de@dersuessmann.de>\n"
"Language: de\n"
"Language-Team: German <arcade-book-de@dersuessmann.de>\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/chapters/16_user_control/user_control.rst:4
msgid "User Control"
msgstr "Steuerung durch den Benutzer"

#: ../../source/chapters/16_user_control/user_control.rst:6
msgid ""
"How do we interact with the user? Get the user to move an object on the "
"screen?"
msgstr ""
"Wie interagieren wir mit dem Benutzer? Wie ermöglichen wir dem Benutzer, "
"ein Objekt auf dem Bildschirm zu bewegen?"

#: ../../source/chapters/16_user_control/user_control.rst:8
msgid ""
"We can do this with the mouse, with the keyboard, or with the game "
"controller."
msgstr ""
"Wir können dies mit der Maus, mit der Tastatur oder mit dem Game-"
"Controller tun."

#: ../../source/chapters/16_user_control/user_control.rst:11
msgid "Move with the Mouse"
msgstr "Bewegen mit der Maus"

#: ../../source/chapters/16_user_control/user_control.rst:13
msgid ""
"The key to managing mouse motion to override the ``on_mouse_motion`` in "
"the ``arcade.Window`` class. That method is called every time the mouse "
"moves. The method definition looks like this:"
msgstr ""
"Der Schlüssel zum Verwalten der Mausbewegungen ist die Methode "
"``on_mouse_motion`` in der Klasse ``arcade.Window`` zu überschreiben. "
"Diese Methode wird jedes Mal aufgerufen, wenn sich die Maus bewegt. Die "
"Methodendefinition sieht folgendermaßen aus:"

#: ../../source/chapters/16_user_control/user_control.rst:17
msgid "def on_mouse_motion(self, x, y, dx, dy):"
msgstr "def on_mouse_motion(self, x, y, dx, dy):"

#: ../../source/chapters/16_user_control/user_control.rst:21
msgid ""
"The ``x`` and ``y`` are the coordinates of the mouse. the ``dx`` and "
"``dy`` represent the change in x and y since the last time the method was"
" called."
msgstr ""
"Das ``x`` und ``y`` sind die Koordinaten der Maus. Das ``dx`` und ``dy`` "
"repräsentieren die Änderung von ``x`` und ``y`` seit dem letzten Aufruf "
"der Methode."

#: ../../source/chapters/16_user_control/user_control.rst:24
msgid ""
"Often when controlling a graphical item on the screen with the mouse, we "
"do not want to see the mouse pointer. If you don't want to see the mouse "
"pointer, in the ``__init__`` method, call the following method in the "
"parent class:"
msgstr ""
"Wenn du ein grafisches Element auf dem Bildschirm mit der Maus steuerst, "
"willst du häufig den Mauszeiger verstecken. Wenn du den Mauszeiger nicht "
"sehen möchtest, rufe in der Methode ``__init__`` die folgende Methode der"
" Elternklasse auf:"

#: ../../source/chapters/16_user_control/user_control.rst:28
msgid "self.set_mouse_visible(False)"
msgstr "self.set_mouse_visible(False)"

#: ../../source/chapters/16_user_control/user_control.rst:32
msgid ""
"The example below takes our ``Ball`` class, and moves it around the "
"screen with the mouse."
msgstr ""
"Das folgende Beispiel nimmt unsere Klasse ``Ball`` und bewegt sie mit der"
" Maus über den Bildschirm."

#: ../../source/chapters/16_user_control/user_control.rst:35
msgid "move_with_mouse.py"
msgstr "move_with_mouse.py"

#: ../../source/chapters/16_user_control/user_control.rst:35
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def on_mouse_motion(self, x, y, dx, dy):\n"
"        \"\"\" Called to update our objects. Happens approximately 60 "
"times per second.\"\"\"\n"
"        self.ball.position_x = x\n"
"        self.ball.position_y = y\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def on_mouse_motion(self, x, y, dx, dy):\n"
"        \"\"\" Called to update our objects. Happens approximately 60 "
"times per second.\"\"\"\n"
"        self.ball.position_x = x\n"
"        self.ball.position_y = y\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/16_user_control/user_control.rst:44
msgid "Mouse Clicks"
msgstr "Mausklicks"

#: ../../source/chapters/16_user_control/user_control.rst:46
msgid ""
"You can also process mouse clicks by defining an ``on_mouse_press`` "
"method:"
msgstr ""
"Wir können Mausklicks auch verarbeiten, indem wir eine "
"``on_mouse_press``-Methode definieren:"

#: ../../source/chapters/16_user_control/user_control.rst:48
msgid ""
"def on_mouse_press(self, x, y, button, modifiers):\n"
"    \"\"\" Called when the user presses a mouse button. \"\"\"\n"
"\n"
"    if button == arcade.MOUSE_BUTTON_LEFT:\n"
"        print(\"Left mouse button pressed at\", x, y)\n"
"    elif button == arcade.MOUSE_BUTTON_RIGHT:\n"
"        print(\"Right mouse button pressed at\", x, y)"
msgstr ""
"def on_mouse_press(self, x, y, button, modifiers):\n"
"    \"\"\" Called when the user presses a mouse button. \"\"\"\n"
"\n"
"    if button == arcade.MOUSE_BUTTON_LEFT:\n"
"        print(\"Left mouse button pressed at\", x, y)\n"
"    elif button == arcade.MOUSE_BUTTON_RIGHT:\n"
"        print(\"Right mouse button pressed at\", x, y)"

#: ../../source/chapters/16_user_control/user_control.rst:59
msgid "Move with the Keyboard"
msgstr "Bewegen mit der Tastatur"

# Replace game controller with keyboard.
#: ../../source/chapters/16_user_control/user_control.rst:61
msgid ""
"Moving with the game controller is similar to our bouncing ball example. "
"There are just two differences:"
msgstr ""
"Das Bewegen mit der Tastatur ähnelt unserem Beispiel für einen "
"springenden Ball. Es gibt nur zwei Unterschiede:"

#: ../../source/chapters/16_user_control/user_control.rst:64
msgid "We control the ``change_x`` and ``change_y`` with the keyboard"
msgstr "Wir steuern die Werte von ``change_x`` und ``change_y`` mit der Tastatur."

#: ../../source/chapters/16_user_control/user_control.rst:65
msgid "When we hit the edge of the screen we stop, rather than bounce."
msgstr "Wenn wir den Bildschirmrand erreichen, halten wir an, statt abzuprallen."

#: ../../source/chapters/16_user_control/user_control.rst:67
msgid ""
"To detect when a key is hit, we override the ``on_key_press`` method. We "
"might think of hitting a key as one event. But it is actually two. When "
"the key is pressed, we start moving. When the key is released we stop "
"moving. That makes for two events. Releasing a key is controlled by "
"``on_key_release``."
msgstr ""
"Um festzustellen, wenn eine Taste gedrückt wird, überschreiben wir die "
"Methode ``on_key_press``. Man könnte vermuten, dass wir einen Tastendruck"
" als ein Ereignis zu bekommen. Aber es sind tatsächlich zwei. Wenn die "
"Taste gedrückt wird, bewegen wir uns. Wenn die Taste losgelassen wird, "
"bleiben wir stehen. Das ergibt zwei Ereignisse. Das Loslassen einer Taste"
" wird durch ``on_key_release`` gesteuert."

#: ../../source/chapters/16_user_control/user_control.rst:72
msgid ""
"These methods have a  ``key`` variable as a parameter that can be "
"compared with an ``if`` statement to the values in the `arcade.key "
"library <http://arcade.academy/arcade.key.html>`_."
msgstr ""
"Diese Methoden haben eine ``key``-Variable als Parameter, die mit einer "
"``if``-Anweisung mit den Werten in `arcade.key "
"<http://arcade.academy/arcade.key.html>`_ verglichen werden kann."

#: ../../source/chapters/16_user_control/user_control.rst:76
msgid ""
"def on_key_press(self, key, modifiers):\n"
"    if key == arcade.key.LEFT:\n"
"        print(\"Left key hit\")\n"
"    elif key == arcade.key.A:\n"
"        print(\"The 'a' key was hit\")"
msgstr ""
"def on_key_press(self, key, modifiers):\n"
"    if key == arcade.key.LEFT:\n"
"        print(\"Left key hit\")\n"
"    elif key == arcade.key.A:\n"
"        print(\"The 'a' key was hit\")"

#: ../../source/chapters/16_user_control/user_control.rst:84
msgid ""
"We can use this in a program to move a ball around the screen. See the "
"highlighted lines in the program below:"
msgstr ""
"Wir können dies in einem Programm verwenden, um einen Ball über den "
"Bildschirm zu bewegen. Siehe die markierten Zeilen im Programm unten:"

#: ../../source/chapters/16_user_control/user_control.rst:87
msgid "move_with_keyboard_simple.py"
msgstr "move_with_keyboard_simple.py"

#: ../../source/chapters/16_user_control/user_control.rst:87
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/16_user_control/user_control.rst:94
msgid "Keep From Moving Off Screen"
msgstr "Verhindern, dass der Bildschirm verlassen wird"

#: ../../source/chapters/16_user_control/user_control.rst:96
msgid ""
"Unfortunately in the prior program, there is nothing that keeps the "
"player from moving off-screen. If we want to stop the player from moving "
"off-screen we need some additional code."
msgstr ""
"Leider gibt es im vorherigen Programm nichts, was die Spieler davon "
"abhält, sich über den Bildschirmrand hinaus zu bewegen. Wenn wir den "
"Spieler daran hindern möchten, sich den Bildschirmbereich zu verlassen, "
"benötigen wir zusätzlichen Code."

#: ../../source/chapters/16_user_control/user_control.rst:100
msgid ""
"We detect the edge by comparing ``position_x`` with the left and right "
"side of the screen For example:"
msgstr ""
"Wir erkennen den Rand, indem wir ``position_x`` mit der linken und "
"rechten Seite des Bildschirms vergleichen. Zum Beispiel:"

#: ../../source/chapters/16_user_control/user_control.rst:103
msgid "if self.position_x < 0:"
msgstr "if self.position_x < 0:"

#: ../../source/chapters/16_user_control/user_control.rst:107
msgid ""
"But this isn't perfect. Because the position specifies the *center* of "
"the ball, by the time the x coordinate is 0 we are already have off the "
"screen. It is better to compare it to the ball's radius:"
msgstr ""
"Das ist aber nicht perfekt. Da die Position die *Mitte* des Balls angibt,"
" haben wir zu dem Zeitpunkt, an dem die x-Koordinate 0 ist, den "
"Bildschirm bereits verlassen. Es ist besser, die Position mit dem Radius "
"des Balls zu vergleichen:"

#: ../../source/chapters/16_user_control/user_control.rst:111
msgid "if self.position_x < self.radius:"
msgstr "if self.position_x < self.radius:"

#: ../../source/chapters/16_user_control/user_control.rst:115
msgid "What do we do once it hits the edge? Just set the value back to the edge:"
msgstr ""
"Was machen wir, wenn er am Rande angekommen ist? Setze den Wert einfach "
"auf den Rand zurück:"

#: ../../source/chapters/16_user_control/user_control.rst:117
msgid ""
"# See if the ball hit the edge of the screen. If so, change direction\n"
"if self.position_x < self.radius:\n"
"    self.position_x = self.radius"
msgstr ""
"# See if the ball hit the edge of the screen. If so, change direction\n"
"if self.position_x < self.radius:\n"
"    self.position_x = self.radius"

#: ../../source/chapters/16_user_control/user_control.rst:123
msgid "Here's a full example:"
msgstr "Hier ist ein vollständiges Beispiel:"

#: ../../source/chapters/16_user_control/user_control.rst:125
msgid "move_with_keyboard_edge_detect.py"
msgstr "move_with_keyboard_edge_detect.py"

#: ../../source/chapters/16_user_control/user_control.rst:125
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 3\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"    def on_draw(self):\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"        self.ball.update()\n"
"\n"
"    def on_key_press(self, key, modifiers):\n"
"        \"\"\" Called whenever the user presses a key. \"\"\"\n"
"        if key == arcade.key.LEFT:\n"
"            self.ball.change_x = -MOVEMENT_SPEED\n"
"        elif key == arcade.key.RIGHT:\n"
"            self.ball.change_x = MOVEMENT_SPEED\n"
"        elif key == arcade.key.UP:\n"
"            self.ball.change_y = MOVEMENT_SPEED\n"
"        elif key == arcade.key.DOWN:\n"
"            self.ball.change_y = -MOVEMENT_SPEED\n"
"\n"
"    def on_key_release(self, key, modifiers):\n"
"        \"\"\" Called whenever a user releases a key. \"\"\"\n"
"        if key == arcade.key.LEFT or key == arcade.key.RIGHT:\n"
"            self.ball.change_x = 0\n"
"        elif key == arcade.key.UP or key == arcade.key.DOWN:\n"
"            self.ball.change_y = 0\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/16_user_control/user_control.rst:132
msgid "Moving with the Game Controller"
msgstr "Bewegen mit dem Game-Controller"

#: ../../source/chapters/16_user_control/user_control.rst:134
msgid ""
"Working with game controllers is a bit more complex. A computer might not"
" have any game controllers, or it might have five controllers plugged in."
msgstr ""
"Die Arbeit mit Game-Controllern ist etwas komplexer. Am Rechner könnte "
"kein Game-Controller oder auch fünf Controller angeschlossen sein."

#: ../../source/chapters/16_user_control/user_control.rst:137
msgid ""
"We can get a list of all game pads that are plugged in with the "
"``get_joysticks`` function. This will either return a list, or it will "
"return nothing at all if there are no game pads."
msgstr ""
"Wir können eine Liste aller mit der Funktion ``get_joysticks`` "
"eingesteckten Gamepads erhalten. Dies gibt entweder eine Liste mit den "
"Gamepads oder eine leere Liste zurück, wenn keine Gamepads vorhanden "
"sind."

#: ../../source/chapters/16_user_control/user_control.rst:141
msgid ""
"Below is a block of code that can be put in an ``__init__`` method for "
"your application that will create an instance variable to represent a "
"game pad if one exists."
msgstr ""
"Nachfolgend finden Sie einen Codeblock, der in eine ``__init__`` -Methode"
" für Ihre Anwendung eingefügt werden kann, mit der eine Objektvariable "
"erstellt wird, die ein Gamepad darstellt, sofern es vorhanden ist."

#: ../../source/chapters/16_user_control/user_control.rst:145
msgid ""
"joysticks = arcade.get_joysticks()\n"
"if joysticks:\n"
"    self.joystick = joysticks[0]\n"
"    self.joystick.open()\n"
"else:\n"
"    print(\"There are no joysticks.\")\n"
"    self.joystick = None"
msgstr ""
"joysticks = arcade.get_joysticks()\n"
"if joysticks:\n"
"    self.joystick = joysticks[0]\n"
"    self.joystick.open()\n"
"else:\n"
"    print(\"There are no joysticks.\")\n"
"    self.joystick = None"

#: ../../source/chapters/16_user_control/user_control.rst:157
msgid "Joystick Values"
msgstr "Joystick-Werte"

#: ../../source/chapters/16_user_control/user_control.rst:159
msgid ""
"After this, you can get the position of the game controller joystick by "
"calling ``self.joystick.x`` and ``self.joystick.y``."
msgstr ""
"Danach können Sie die Position des Game-Controller-Joysticks ermitteln, "
"indem Sie ``self.joystick.x`` und ``self.joystick.y`` aufrufen."

#: ../../source/chapters/16_user_control/user_control.rst:162
msgid "Try this, combined with the initialization code from above:"
msgstr "Probiere dies, kombiniert mit dem Initialisierungscode von oben, aus:"

#: ../../source/chapters/16_user_control/user_control.rst:164
msgid "move_with_game_controller_print.py"
msgstr "move_with_game_controller_print.py"

#: ../../source/chapters/16_user_control/user_control.rst:164
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"            print(self.joystick.x, self.joystick.y)\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"            print(self.joystick.x, self.joystick.y)\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"

#: ../../source/chapters/16_user_control/user_control.rst:170
msgid ""
"Run the program and see the values it prints out for your game controller"
" as you move the joystick on it around."
msgstr ""
"Führe das Programm aus und sieh dir die Werte an, die es für Ihren Game-"
"Controller ausgibt, wenn du den Joystick bewegen."

#: ../../source/chapters/16_user_control/user_control.rst:173
msgid "The values will be between -1 and +1, with 0 being a centered joystick."
msgstr "Die Werte liegen zwischen -1 und +1, wobei 0 ein zentrierter Joystick ist."

#: ../../source/chapters/16_user_control/user_control.rst:174
msgid ""
"The x-axis numbers will be negative if the stick goes left, positive for "
"right."
msgstr ""
"Die Zahlen auf der x-Achse sind negativ, wenn der Joystick nach links "
"geht, positiv nach rechts."

#: ../../source/chapters/16_user_control/user_control.rst:175
msgid ""
"The y-axis numbers will be opposite of what you might expect. Negative "
"for up, positive for down."
msgstr ""
"Die Zahlen für y-Achse sind eventuell entgegengesetzt zu dem was du "
"erwartest. Negativ für oben, positiv für unten."

#: ../../source/chapters/16_user_control/user_control.rst:179
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\c.jpg"
msgstr ".. image:: chapters/16_user_control/c.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:179
msgid "Centered (0, 0)"
msgstr "Zentriert (0, 0)"

#: ../../source/chapters/16_user_control/user_control.rst:183
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\d.jpg"
msgstr ".. image:: chapters/16_user_control/d.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:183
msgid "Down (0, 1)"
msgstr "Unten (0, 1)"

#: ../../source/chapters/16_user_control/user_control.rst:187
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\dl.jpg"
msgstr ".. image:: chapters/16_user_control/dl.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:187
msgid "Down/Left (-1, 1)"
msgstr "Runter / links (-1, 1)"

#: ../../source/chapters/16_user_control/user_control.rst:191
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\dr.jpg"
msgstr ".. image:: chapters/16_user_control/dr.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:191
msgid "Down/Right (1, 1)"
msgstr "Unten / Rechts (1, 1)"

#: ../../source/chapters/16_user_control/user_control.rst:195
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\u.jpg"
msgstr ".. image:: chapters/16_user_control/u.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:195
msgid "Up (0, -1)"
msgstr "Auf (0, -1)"

#: ../../source/chapters/16_user_control/user_control.rst:199
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\ul.jpg"
msgstr ".. image:: chapters/16_user_control/ul.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:199
msgid "Up/Left (-1, -1)"
msgstr "Oben / Links (-1, -1)"

#: ../../source/chapters/16_user_control/user_control.rst:203
#, fuzzy
msgid ".. image:: chapters\\16_user_control\\ur.jpg"
msgstr ".. image:: chapters/16_user_control/ur.jpg"

#: ../../source/chapters/16_user_control/user_control.rst:203
msgid "Up/Right (1, -1)"
msgstr "Oben / Rechts (1, -1)"

#: ../../source/chapters/16_user_control/user_control.rst:205
msgid "We can move the ball by adding the following code to the ``update``:"
msgstr ""
"Wir können den Ball bewegen, indem wir den folgenden Code zu ``update`` "
"hinzufügen:"

#: ../../source/chapters/16_user_control/user_control.rst:207
msgid ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x\n"
"        self.ball.change_y = -self.joystick.y"
msgstr ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x\n"
"        self.ball.change_y = -self.joystick.y"

#: ../../source/chapters/16_user_control/user_control.rst:219
msgid ""
"Notice the ``-`` we put in front of setting the y vector. If we don't do "
"this, the ball will move opposite of what we expect when going up/down. "
"This is because the joystick has y values mapped opposite of how we'd "
"normally expect. There's a long story to that, which I will not bore you "
"with now."
msgstr ""
"Beachte das ``-``, das wir vor das Setzen des y-Werts schreiben. Wenn wir"
" dies nicht tun, bewegt sich der Ball entgegengesetzt zu dem, was wir "
"beim Auf- und Absteigen erwarten. Dies liegt daran, dass der Joystick "
"y-Werte hat, die entgegengesetzt zu dem sind, was wir normalerweise "
"erwarten würden. Das hat eine lange Geschichte, mit der ich Euch jetzt "
"nicht langweilen werde."

#: ../../source/chapters/16_user_control/user_control.rst:224
msgid ""
"But with this code our ball moves *so slow*. How do we speed it up? We "
"can make it run five times faster by multiplying by five if we want."
msgstr ""
"Aber mit diesem Code bewegt sich unser Ball *so langsam*. Wie "
"beschleunigen wir das? Wir können es fünfmal schneller machen, indem wir "
"es mit fünf multiplizieren, wenn wir wollen."

#: ../../source/chapters/16_user_control/user_control.rst:227
msgid ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x * 5\n"
"        self.ball.change_y = -self.joystick.y * 5"
msgstr ""
"def update(self, delta_time):\n"
"\n"
"    # Update the position according to the game controller\n"
"    if self.joystick:\n"
"        print(self.joystick.x, self.joystick.y)\n"
"\n"
"        self.ball.change_x = self.joystick.x * 5\n"
"        self.ball.change_y = -self.joystick.y * 5"

#: ../../source/chapters/16_user_control/user_control.rst:239
msgid ""
"Or better yet, define a constant variable at the top of your program and "
"use that. In our final example below, we'll do just that."
msgstr ""
"Oder noch besser, definiere eine konstante Variable am Anfang des "
"Programms und verwende diese. In unserem letzten Beispiel unten machen "
"wir genau das."

#: ../../source/chapters/16_user_control/user_control.rst:244
msgid "Deadzone"
msgstr "Toter Bereich"

#: ../../source/chapters/16_user_control/user_control.rst:246
msgid "What if your ball 'drifts' when you have the joystick centered?"
msgstr ""
"Was ist, wenn der Ball \"driftet\", wenn der Joystick zentriert in der "
"Mitte steht?"

#: ../../source/chapters/16_user_control/user_control.rst:248
msgid ""
"Joysticks are mechanical. A centered joystick might have a value not at "
"0, but at 0.0001 or some small number. This will make for a small "
"\"drift\" on a person's character. We often counteract this by having a "
"\"dead zone\" where if the number is below a certain value, we just "
"assume it is zero to eliminate the drift."
msgstr ""
"Joysticks funktionieren mechanisch. Ein zentrierter Joystick kann einen "
"Wert haben, der nicht bei 0, sondern bei 0,0001 oder einer anderen "
"kleinen Zahl liegt. Dies führt zu einem kleinen \"Driften\" der "
"Spielfigur. Wir wirken dem oft mit einer \"toten Bereich\" entgegen, "
"indem wir, wenn die Zahl unter einem bestimmten Wert liegt, einfach davon"
" ausgehen, dass sie Null ist, um die Abweichung zu beseitigen."

#: ../../source/chapters/16_user_control/user_control.rst:254
msgid "See the highlighted lines for how we take care of the dead zone:"
msgstr ""
"In den hervorgehobenen Linien sehen Sie, wie wir uns um den toten Bereich"
" kümmern:"

#: ../../source/chapters/16_user_control/user_control.rst:256
msgid "move_with_game_controller.py"
msgstr "move_with_game_controller.py"

#: ../../source/chapters/16_user_control/user_control.rst:256
msgid ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered "
"joystick\n"
"            if abs(self.joystick.x) < DEAD_ZONE:\n"
"                self.ball.change_x = 0\n"
"            else:\n"
"                self.ball.change_x = self.joystick.x * MOVEMENT_SPEED\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered "
"joystick\n"
"            if abs(self.joystick.y) < DEAD_ZONE:\n"
"                self.ball.change_y = 0\n"
"            else:\n"
"                self.ball.change_y = -self.joystick.y * MOVEMENT_SPEED\n"
"\n"
"        self.ball.update()\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"
msgstr ""
"import arcade\n"
"\n"
"SCREEN_WIDTH = 640\n"
"SCREEN_HEIGHT = 480\n"
"MOVEMENT_SPEED = 5\n"
"DEAD_ZONE = 0.02\n"
"\n"
"\n"
"class Ball:\n"
"    def __init__(self, position_x, position_y, change_x, change_y, "
"radius, color):\n"
"\n"
"        # Take the parameters of the init function above, and create "
"instance variables out of them.\n"
"        self.position_x = position_x\n"
"        self.position_y = position_y\n"
"        self.change_x = change_x\n"
"        self.change_y = change_y\n"
"        self.radius = radius\n"
"        self.color = color\n"
"\n"
"    def draw(self):\n"
"        \"\"\" Draw the balls with the instance variables we have. \"\"\""
"\n"
"        arcade.draw_circle_filled(self.position_x, self.position_y, "
"self.radius, self.color)\n"
"\n"
"    def update(self):\n"
"        # Move the ball\n"
"        self.position_y += self.change_y\n"
"        self.position_x += self.change_x\n"
"\n"
"        # See if the ball hit the edge of the screen. If so, change "
"direction\n"
"        if self.position_x < self.radius:\n"
"            self.position_x = self.radius\n"
"\n"
"        if self.position_x > SCREEN_WIDTH - self.radius:\n"
"            self.position_x = SCREEN_WIDTH - self.radius\n"
"\n"
"        if self.position_y < self.radius:\n"
"            self.position_y = self.radius\n"
"\n"
"        if self.position_y > SCREEN_HEIGHT - self.radius:\n"
"            self.position_y = SCREEN_HEIGHT - self.radius\n"
"\n"
"\n"
"class MyGame(arcade.Window):\n"
"\n"
"    def __init__(self, width, height, title):\n"
"\n"
"        # Call the parent class's init function\n"
"        super().__init__(width, height, title)\n"
"\n"
"        # Make the mouse disappear when it is over the window.\n"
"        # So we just see our object, not the pointer.\n"
"        self.set_mouse_visible(False)\n"
"\n"
"        arcade.set_background_color(arcade.color.ASH_GREY)\n"
"\n"
"        # Create our ball\n"
"        self.ball = Ball(50, 50, 0, 0, 15, arcade.color.AUBURN)\n"
"\n"
"        # Get a list of all the game controllers that are plugged in\n"
"        joysticks = arcade.get_joysticks()\n"
"\n"
"        # If we have a game controller plugged in, grab it and\n"
"        # make an instance variable out of it.\n"
"        if joysticks:\n"
"            self.joystick = joysticks[0]\n"
"            self.joystick.open()\n"
"        else:\n"
"            print(\"There are no joysticks.\")\n"
"            self.joystick = None\n"
"\n"
"    def on_draw(self):\n"
"\n"
"        \"\"\" Called whenever we need to draw the window. \"\"\"\n"
"        arcade.start_render()\n"
"        self.ball.draw()\n"
"\n"
"    def update(self, delta_time):\n"
"\n"
"        # Update the position according to the game controller\n"
"        if self.joystick:\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered "
"joystick\n"
"            if abs(self.joystick.x) < DEAD_ZONE:\n"
"                self.ball.change_x = 0\n"
"            else:\n"
"                self.ball.change_x = self.joystick.x * MOVEMENT_SPEED\n"
"\n"
"            # Set a \"dead zone\" to prevent drive from a centered "
"joystick\n"
"            if abs(self.joystick.y) < DEAD_ZONE:\n"
"                self.ball.change_y = 0\n"
"            else:\n"
"                self.ball.change_y = -self.joystick.y * MOVEMENT_SPEED\n"
"\n"
"        self.ball.update()\n"
"\n"
"\n"
"def main():\n"
"    window = MyGame(640, 480, \"Drawing Example\")\n"
"    arcade.run()\n"
"\n"
"\n"
"main()\n"

